<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DrawGuess - Online Drawing Game | Beniah Games</title>
    
    <!-- Supabase CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        :root {
            --bg: #0d0e10;
            --panel: #171a21;
            --border: #2a2d35;
            --text: #e8eaed;
            --muted: #9aa0a6;
            --accent: #ffcc00;
            --accent-2: #ffe066;
            --success: #34a853;
            --error: #ea4335;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: var(--panel);
            border-bottom: 1px solid var(--border);
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent);
        }

        .room-info {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .room-code {
            background: var(--bg);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .main-container {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 1rem;
            padding: 1rem;
            max-height: calc(100vh - 80px);
        }

        .game-area {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .game-status {
            background: var(--panel);
            padding: 1rem;
            border-radius: 12px;
            border: 1px solid var(--border);
            text-align: center;
        }

        .current-word {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent);
            margin-bottom: 0.5rem;
        }

        .timer {
            font-size: 1.2rem;
            color: var(--muted);
        }

        .canvas-container {
            background: var(--panel);
            border-radius: 12px;
            border: 1px solid var(--border);
            padding: 1rem;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .drawing-tools {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .tool-btn {
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tool-btn:hover {
            background: var(--border);
        }

        .tool-btn.active {
            background: var(--accent);
            color: var(--bg);
        }

        .color-picker {
            display: flex;
            gap: 0.25rem;
        }

        .color-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid var(--border);
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .color-btn:hover {
            transform: scale(1.1);
        }

        .color-btn.active {
            border-color: var(--accent);
            transform: scale(1.2);
        }

        .brush-size {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .size-slider {
            width: 100px;
        }

        #drawingCanvas {
            border: 2px solid var(--border);
            border-radius: 8px;
            background: white;
            cursor: crosshair;
            max-width: 100%;
            max-height: 400px;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .players-panel {
            background: var(--panel);
            border-radius: 12px;
            border: 1px solid var(--border);
            padding: 1rem;
        }

        .panel-title {
            font-weight: bold;
            margin-bottom: 1rem;
            color: var(--accent);
        }

        .player-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .player {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background: var(--bg);
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .player.current-turn {
            border-color: var(--accent);
            background: rgba(255, 204, 0, 0.1);
        }

        .player-name {
            font-weight: 500;
        }

        .player-score {
            color: var(--accent);
            font-weight: bold;
        }

        .chat-panel {
            background: var(--panel);
            border-radius: 12px;
            border: 1px solid var(--border);
            padding: 1rem;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 1rem;
            max-height: 300px;
        }

        .message {
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            border-radius: 8px;
        }

        .message.normal {
            background: var(--bg);
        }

        .message.correct-guess {
            background: rgba(52, 168, 83, 0.2);
            border: 1px solid var(--success);
            font-weight: bold;
        }

        .message.correct {
            background: rgba(52, 168, 83, 0.2);
            border: 1px solid var(--success);
        }

        .message.system {
            background: rgba(255, 204, 0, 0.1);
            border: 1px solid var(--accent);
            font-style: italic;
        }

        .message-author {
            font-weight: bold;
            color: var(--accent);
        }

        .chat-input {
            display: flex;
            gap: 0.5rem;
        }

        .chat-input input {
            flex: 1;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.5rem;
            border-radius: 8px;
        }

        .chat-input button {
            background: var(--accent);
            color: var(--bg);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
        }

        .join-room {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .join-form {
            background: var(--panel);
            padding: 2rem;
            border-radius: 12px;
            border: 1px solid var(--border);
            max-width: 400px;
            width: 90%;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--muted);
        }

        .form-group input {
            width: 100%;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.75rem;
            border-radius: 8px;
        }

        .btn {
            background: var(--accent);
            color: var(--bg);
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            margin-top: 1rem;
        }

        .btn:hover {
            background: var(--accent-2);
        }

        .btn-secondary {
            background: var(--bg);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        @media (max-width: 768px) {
            .main-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
                padding: 0.5rem;
                gap: 0.5rem;
            }
            
            .sidebar {
                order: -1;
            }
            
            .game-area {
                gap: 0.5rem;
            }
            
            .drawing-tools {
                flex-wrap: wrap;
                gap: 0.5rem;
                justify-content: center;
            }
            
            .drawing-section {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 0.5rem;
            }
            
            #drawingCanvas {
                max-height: 60vh;
                width: 95vw;
                max-width: 95vw;
                height: auto;
                margin: 0 auto;
            }
            
            .players-panel, .chat-panel {
                margin: 0;
                padding: 0.75rem;
            }
            
            .game-status {
                padding: 0.75rem;
                margin: 0;
            }
        }
    </style>
</head>
<body>
    <!-- Join Room Modal -->
    <div class="join-room" id="joinModal">
        <div class="join-form">
            <h2 style="margin-bottom: 1rem; color: var(--accent);">Join DrawGuess</h2>
            <div class="form-group">
                <label>Playing as: <span id="currentUserName" style="color: var(--accent); font-weight: bold;">Guest</span></label>
                <p style="color: var(--muted); font-size: 0.9rem; margin-top: 0.5rem;">
                    <a href="../user/" style="color: var(--accent);">Sign in</a> to use your profile name
                </p>
            </div>
            <div class="form-group">
                <label for="roomCode">Room Code (optional)</label>
                <input type="text" id="roomCode" placeholder="Leave empty to create new room" maxlength="6">
            </div>
            <button class="btn" onclick="joinGame()">Join Game</button>
            <button class="btn btn-secondary" onclick="createRoom()">Create New Room</button>
        </div>
    </div>

    <!-- Main Game Interface -->
    <div class="header">
        <div class="logo">DrawGuess</div>
        <div class="room-info">
            <div class="room-code">Room: <span id="currentRoom">-</span></div>
            <div>Players: <span id="playerCount">0</span>/10</div>
        </div>
    </div>

    <div class="main-container">
        <div class="game-area">
            <div class="game-status">
                <div class="current-word" id="currentWord">Waiting for players...</div>
                <div class="timer" id="gameTimer">Time: <span id="timer">0</span>s</div>
                <div id="gamePhase" style="margin-top: 0.5rem; color: var(--muted);">Waiting to start</div>
                <div class="game-controls" style="margin-top: 0.5rem;">
                    <button id="startGameBtn" onclick="startNewRound()" style="display: none; margin-right: 0.5rem;">Start Game</button>
                    <button id="clearCanvasBtn" onclick="clearCanvas()" style="font-size: 0.8rem;">Clear Canvas</button>
                </div>
            </div>

            <div class="canvas-container">
                <div class="drawing-section">
                    <div class="drawing-tools">
                        <button class="tool-btn active" data-tool="pen">Pen</button>
                        <button class="tool-btn" data-tool="eraser">Eraser</button>
                        <button class="tool-btn" onclick="clearCanvas()">Clear</button>
                        
                        <div class="color-picker">
                            <div class="color-btn active" data-color="#000000" style="background: #000000;"></div>
                            <div class="color-btn" data-color="#ff0000" style="background: #ff0000;"></div>
                            <div class="color-btn" data-color="#00ff00" style="background: #00ff00;"></div>
                            <div class="color-btn" data-color="#0000ff" style="background: #0000ff;"></div>
                            <div class="color-btn" data-color="#ffff00" style="background: #ffff00;"></div>
                            <div class="color-btn" data-color="#ff00ff" style="background: #ff00ff;"></div>
                            <div class="color-btn" data-color="#00ffff" style="background: #00ffff;"></div>
                            <div class="color-btn" data-color="#ffffff" style="background: #ffffff; border-color: #666;"></div>
                        </div>
                        
                        <div class="brush-size">
                            <span>Size:</span>
                            <input type="range" class="size-slider" min="1" max="20" value="3" id="brushSize">
                            <span id="sizeDisplay">3px</span>
                        </div>
                    </div>
                    
                    <canvas id="drawingCanvas" width="800" height="400"></canvas>
                </div>
            </div>
        </div>

        <div class="sidebar">
            <div class="players-panel">
                <div class="panel-title">Players</div>
                <div class="player-list" id="playerList">
                    <!-- Players will be populated here -->
                </div>
            </div>

            <div class="chat-panel">
                <div class="panel-title">Chat & Guesses</div>
                <div class="chat-messages" id="chatMessages">
                    <!-- Messages will appear here -->
                </div>
                <div class="chat-input">
                    <input type="text" id="chatInput" placeholder="Type your guess..." maxlength="100">
                    <button onclick="sendMessage()">Send</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Supabase configuration
        // Get these from: https://app.supabase.com â†’ Your Project â†’ Settings â†’ API
        const SUPABASE_URL = 'https://nqhejsnfwfcilktnyqbi.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5xaGVqc25md2ZjaWxrdG55cWJpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgzODQ3NzAsImV4cCI6MjA3Mzk2MDc3MH0.8ngjb28rPVPCj4SnLtLSeUFbeAoFsrcQlZXpq2D19Ag';
        
        // Initialize Supabase client
        let supabase = null;
        let isSupabaseConfigured = false;
        
        try {
            if (SUPABASE_URL !== 'YOUR_SUPABASE_URL' && SUPABASE_ANON_KEY !== 'YOUR_SUPABASE_ANON_KEY') {
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                isSupabaseConfigured = true;
                console.log('Supabase configured - Real-time multiplayer enabled');
            } else {
                console.log('Supabase not configured - Running in demo mode');
                // Show configuration message
                setTimeout(() => {
                    addSystemMessage('âš ï¸ Demo Mode: To enable real multiplayer, configure Supabase credentials in the code');
                }, 2000);
            }
        } catch (error) {
            console.error('Error initializing Supabase:', error);
            isSupabaseConfigured = false;
        }
        
        // Game state
        let gameState = {
            room: null,
            roomId: null,
            myId: null,
            myName: null,
            players: new Map(),
            currentDrawer: null,
            currentWord: null,
            timeLeft: 60,
            round: 1,
            maxRounds: 3,
            isDrawing: false,
            gameStarted: false,
            subscriptions: []
        };

        // Drawing state
        let canvas, ctx;
        let isDrawingMode = false;
        let currentTool = 'pen';
        let currentColor = '#000000';
        let currentSize = 3;
        let lastX = 0;
        let lastY = 0;

        // Sample words for drawing
        const words = [
            'cat', 'dog', 'house', 'car', 'tree', 'sun', 'moon', 'star', 'fish', 'bird',
            'flower', 'book', 'phone', 'computer', 'chair', 'table', 'door', 'window',
            'apple', 'banana', 'pizza', 'cake', 'ice cream', 'guitar', 'piano', 'ball',
            'bicycle', 'airplane', 'boat', 'train', 'elephant', 'lion', 'butterfly',
            'rainbow', 'cloud', 'mountain', 'ocean', 'beach', 'castle', 'robot'
        ];

        // Initialize game
        async function initGame() {
            canvas = document.getElementById('drawingCanvas');
            ctx = canvas.getContext('2d');
            
            setupCanvas();
            setupEventListeners();
            
            // Get user's name and ID from authentication
            await getUserName();
            
            // Start periodic room cleanup (every 30 minutes)
            if (isSupabaseConfigured) {
                setInterval(periodicRoomCleanup, 30 * 60 * 1000);
                // Run initial cleanup after 5 seconds
                setTimeout(periodicRoomCleanup, 5000);
            }
        }

        async function getUserName() {
            // Check if user is authenticated
            const user = await getCurrentUser();
            const signInMessage = document.querySelector('.join-form p');
            
            if (user && user.username) {
                gameState.myId = user.id;
                gameState.myName = user.username;
                document.getElementById('currentUserName').textContent = user.username;
                // Hide sign-in message for authenticated users
                if (signInMessage) signInMessage.style.display = 'none';
            } else {
                // Generate a guest name and ID
                gameState.myId = 'guest_' + Math.random().toString(36).substr(2, 9);
                gameState.myName = 'Guest' + Math.floor(Math.random() * 1000);
                document.getElementById('currentUserName').textContent = gameState.myName;
                // Show sign-in message for guests
                if (signInMessage) signInMessage.style.display = 'block';
            }
        }

        async function getCurrentUser() {
            if (!isSupabaseConfigured) {
                // Fallback to localStorage for demo mode
                try {
                    const userData = localStorage.getItem('user');
                    if (userData) {
                        return JSON.parse(userData);
                    }
                } catch (e) {
                    console.log('No local user data found');
                }
                return null;
            }
            
            try {
                // Get current Supabase user
                const { data: { user }, error } = await supabase.auth.getUser();
                if (error) throw error;
                
                if (user) {
                    // Get user profile with username
                    const { data: profile, error: profileError } = await supabase
                        .from('profiles')
                        .select('username')
                        .eq('id', user.id)
                        .single();
                    
                    if (profileError) {
                        console.log('No profile found, using email');
                        return { 
                            id: user.id, 
                            username: user.email?.split('@')[0] || 'User' 
                        };
                    }
                    
                    return { 
                        id: user.id, 
                        username: profile.username || user.email?.split('@')[0] || 'User' 
                    };
                }
            } catch (e) {
                console.log('Error getting user:', e);
            }
            
            // Fallback to localStorage for backward compatibility
            try {
                const userData = localStorage.getItem('user');
                if (userData) {
                    return JSON.parse(userData);
                }
            } catch (e) {
                console.log('No local user data found');
            }
            
            return null;
        }

        function setupCanvas() {
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = currentSize;
            
            // Mouse events
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            
            // Touch events for mobile
            canvas.addEventListener('touchstart', handleTouch);
            canvas.addEventListener('touchmove', handleTouch);
            canvas.addEventListener('touchend', stopDrawing);
        }

        function setupEventListeners() {
            // Tool selection
            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelector('.tool-btn.active').classList.remove('active');
                    btn.classList.add('active');
                    currentTool = btn.dataset.tool;
                });
            });

            // Color selection
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelector('.color-btn.active').classList.remove('active');
                    btn.classList.add('active');
                    currentColor = btn.dataset.color;
                    ctx.strokeStyle = currentColor;
                });
            });

            // Brush size
            document.getElementById('brushSize').addEventListener('input', (e) => {
                currentSize = e.target.value;
                ctx.lineWidth = currentSize;
                document.getElementById('sizeDisplay').textContent = currentSize + 'px';
            });

            // Chat input
            document.getElementById('chatInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
        }

        async function startDrawing(e) {
            if (gameState.currentDrawer !== gameState.myId) return;
            
            isDrawingMode = true;
            const rect = canvas.getBoundingClientRect();
            lastX = e.clientX - rect.left;
            lastY = e.clientY - rect.top;
            
            // Save start stroke (only if Supabase is configured)
            if (isSupabaseConfigured) {
                await saveStroke({
                    x: lastX,
                    y: lastY,
                    color: currentColor,
                    size: currentSize,
                    tool: currentTool,
                    type: 'start'
                });
            }
        }

        async function draw(e) {
            if (!isDrawingMode || gameState.currentDrawer !== gameState.myId) return;
            
            const rect = canvas.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;
            
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(currentX, currentY);
            
            if (currentTool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = currentSize * 2;
            } else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.lineWidth = currentSize;
            }
            
            ctx.stroke();
            
            // Save stroke to database for real-time sync (only if Supabase is configured)
            if (isSupabaseConfigured) {
                await saveStroke({
                    fromX: lastX,
                    fromY: lastY,
                    toX: currentX,
                    toY: currentY,
                    color: currentColor,
                    size: currentSize,
                    tool: currentTool,
                    type: 'draw'
                });
            }
            
            lastX = currentX;
            lastY = currentY;
        }

        async function saveStroke(strokeData) {
            if (!isSupabaseConfigured) {
                // Demo mode - no need to save strokes
                return;
            }
            
            if (!gameState.roomId) return;
            
            try {
                const { error } = await supabase
                    .from('drawing_strokes')
                    .insert({
                        room_id: gameState.roomId,
                        user_id: gameState.myId.startsWith('guest_') ? null : gameState.myId,
                        round_number: gameState.round,
                        stroke_data: strokeData,
                        stroke_order: Date.now()
                    });
                
                if (error) throw error;
                
            } catch (error) {
                console.error('Error saving stroke:', error);
            }
        }

        function drawStrokeFromData(strokeData) {
            const { fromX, fromY, toX, toY, color, size, tool, type } = strokeData;
            
            ctx.strokeStyle = color;
            ctx.lineWidth = size;
            
            if (tool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = size * 2;
            } else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.lineWidth = size;
            }
            
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
        }

        function stopDrawing() {
            isDrawingMode = false;
        }

        function handleTouch(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent(e.type === 'touchstart' ? 'mousedown' : 
                                            e.type === 'touchmove' ? 'mousemove' : 'mouseup', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        }

        function clearCanvas() {
            if (!gameState.isMyTurn) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        async function joinGame() {
            const roomCode = document.getElementById('roomCode').value.trim();
            
            // Name is already set by getUserName()
            if (!gameState.myName) {
                alert('Unable to get player name. Please refresh and try again.');
                return;
            }
            
            if (!isSupabaseConfigured) {
                // Demo mode - simulate joining
                gameState.room = roomCode.toUpperCase() || generateRoomCode();
                gameState.roomId = gameState.room;
                gameState.players.set(gameState.myId, {
                    id: gameState.myId,
                    name: gameState.myName,
                    score: 0
                });
                
                // Add some demo players
                if (!roomCode) {
                    addPlayer('demo1', 'Demo Player 1', 0);
                    addPlayer('demo2', 'Demo Player 2', 0);
                }
                
                document.getElementById('joinModal').style.display = 'none';
                document.getElementById('currentRoom').textContent = gameState.room;
                addSystemMessage(`${roomCode ? 'Joined' : 'Created'} room: ${gameState.room} (Demo Mode)`);
                startGame();
                return;
            }
            
            try {
                if (roomCode) {
                    // Join existing room
                    await joinExistingRoom(roomCode);
                } else {
                    // Create new room
                    await createNewRoom();
                }
                
                document.getElementById('joinModal').style.display = 'none';
                setupRealtimeSubscriptions();
                
            } catch (error) {
                console.error('Error joining game:', error);
                alert('Failed to join game. Please try again.');
            }
        }

        async function createNewRoom() {
            // Generate room code
            const { data: roomCode, error: codeError } = await supabase
                .rpc('generate_room_code');
            
            if (codeError) throw codeError;
            
            // Create room in database
            const { data: room, error: roomError } = await supabase
                .from('game_rooms')
                .insert({
                    room_code: roomCode,
                    host_id: gameState.myId.startsWith('guest_') ? null : gameState.myId,
                    status: 'waiting'
                })
                .select()
                .single();
            
            if (roomError) throw roomError;
            
            gameState.room = roomCode;
            gameState.roomId = room.id;
            document.getElementById('currentRoom').textContent = roomCode;
            
            // Add player to room
            await addPlayerToRoom(room.id);
            
            // Load initial game data (including players)
            await loadInitialGameData();
            
            addSystemMessage(`Room ${roomCode} created! Share this code with friends.`);
        }

        async function joinExistingRoom(roomCode) {
            // Find room by code
            const { data: room, error: roomError } = await supabase
                .from('game_rooms')
                .select('*')
                .eq('room_code', roomCode.toUpperCase())
                .eq('status', 'waiting')
                .single();
            
            if (roomError || !room) {
                throw new Error('Room not found or already started');
            }
            
            // Check if room is full
            const { count, error: countError } = await supabase
                .from('game_players')
                .select('*', { count: 'exact', head: true })
                .eq('room_id', room.id);
            
            if (countError) throw countError;
            
            if (count >= room.max_players) {
                throw new Error('Room is full');
            }
            
            gameState.room = roomCode.toUpperCase();
            gameState.roomId = room.id;
            document.getElementById('currentRoom').textContent = roomCode.toUpperCase();
            
            // Add player to room
            await addPlayerToRoom(room.id);
            
            // Load initial game data (including players)
            await loadInitialGameData();
            
            addSystemMessage(`Joined room ${roomCode.toUpperCase()}`);
        }

        async function addPlayerToRoom(roomId) {
            const { error } = await supabase
                .from('game_players')
                .insert({
                    room_id: roomId,
                    user_id: gameState.myId, // Store the full user ID including guest IDs
                    username: gameState.myName,
                    score: 0
                });
            
            if (error && error.code !== '23505') { // Ignore duplicate key error
                throw error;
            }
        }

        function createRoom() {
            // Name is already set by getUserName()
            if (!gameState.myName) {
                alert('Unable to get player name. Please refresh and try again.');
                return;
            }
            
            document.getElementById('roomCode').value = '';
            joinGame();
        }

        function setupRealtimeSubscriptions() {
            if (!isSupabaseConfigured || !gameState.roomId) return;
            
            try {
                // Subscribe to players in the room
                const playersSubscription = supabase
                    .channel(`room-${gameState.roomId}-players`)
                    .on('postgres_changes', {
                        event: '*',
                        schema: 'public',
                        table: 'game_players',
                        filter: `room_id=eq.${gameState.roomId}`
                    }, handlePlayerUpdate)
                    .subscribe();

                // Subscribe to messages in the room
                const messagesSubscription = supabase
                    .channel(`room-${gameState.roomId}-messages`)
                    .on('postgres_changes', {
                        event: 'INSERT',
                        schema: 'public',
                        table: 'game_messages',
                        filter: `room_id=eq.${gameState.roomId}`
                    }, handleNewMessage)
                    .subscribe();

                // Subscribe to drawing strokes
                const drawingSubscription = supabase
                    .channel(`room-${gameState.roomId}-drawing`)
                    .on('postgres_changes', {
                        event: 'INSERT',
                        schema: 'public',
                        table: 'drawing_strokes',
                        filter: `room_id=eq.${gameState.roomId}`
                    }, handleDrawingStroke)
                    .subscribe();

                // Subscribe to room updates
                const roomSubscription = supabase
                    .channel(`room-${gameState.roomId}-updates`)
                    .on('postgres_changes', {
                        event: 'UPDATE',
                        schema: 'public',
                        table: 'game_rooms',
                        filter: `id=eq.${gameState.roomId}`
                    }, handleRoomUpdate)
                    .subscribe();

                gameState.subscriptions = [
                    playersSubscription,
                    messagesSubscription,
                    drawingSubscription,
                    roomSubscription
                ];

                console.log('Real-time subscriptions established');
                
                // Load initial data
                loadInitialGameData();
            } catch (error) {
                console.error('Error setting up subscriptions:', error);
            }
        }

        async function loadInitialGameData() {
            if (!isSupabaseConfigured) {
                // Demo mode - no initial data to load
                return;
            }
            
            try {
                // Load existing players
                const { data: players, error: playersError } = await supabase
                    .from('game_players')
                    .select('*')
                    .eq('room_id', gameState.roomId);

                if (playersError) throw playersError;

                // Clear and reload players
                gameState.players.clear();
                document.getElementById('playersList').innerHTML = '';
                
                players.forEach(player => {
                    addPlayer(player.user_id, player.username, player.score);
                });

                // Load recent messages
                const { data: messages, error: messagesError } = await supabase
                    .from('game_messages')
                    .select('*')
                    .eq('room_id', gameState.roomId)
                    .order('created_at', { ascending: true })
                    .limit(50);

                if (messagesError) throw messagesError;

                messages.forEach(msg => {
                    if (msg.message_type === 'system') {
                        addSystemMessage(msg.message);
                    } else {
                        addChatMessage(msg.username, msg.message);
                    }
                });

            } catch (error) {
                console.error('Error loading initial data:', error);
            }
        }

        function handlePlayerUpdate(payload) {
            const player = payload.new;
            if (payload.eventType === 'INSERT') {
                addPlayer(player.user_id, player.username, player.score);
                if (player.username !== gameState.myName) {
                    addSystemMessage(`${player.username} joined the room`);
                }
            } else if (payload.eventType === 'UPDATE') {
                updatePlayerScore(player.user_id, player.score);
            } else if (payload.eventType === 'DELETE') {
                removePlayer(player.user_id);
                addSystemMessage(`${player.username} left the room`);
            }
        }

        function handleNewMessage(payload) {
            const message = payload.new;
            
            // Don't show our own messages (they're already displayed locally)
            if (message.user_id === gameState.myId) return;
            
            if (message.message_type === 'system') {
                addSystemMessage(message.message);
            } else {
                addChatMessage(message.username, message.message, message.is_correct_guess ? 'correct-guess' : 'normal');
                
                // Check if it's a correct guess
                if (message.is_correct_guess) {
                    addSystemMessage(`ðŸŽ‰ ${message.username} guessed correctly!`);
                }
            }
        }
        
        function checkGuess(message, playerId) {
            if (!gameState.currentWord || !gameState.roundStarted) return false;
            if (playerId === gameState.currentDrawer) return false; // Drawer can't guess
            
            const guess = message.toLowerCase().trim();
            const word = gameState.currentWord.toLowerCase().trim();
            
            // Exact match
            if (guess === word) return true;
            
            // Close match (for typos) - only for longer words
            if (guess.length > 3 && word.length > 3) {
                const similarity = calculateSimilarity(guess, word);
                return similarity > 0.85; // 85% similarity threshold
            }
            
            return false;
        }
        
        function calculateSimilarity(str1, str2) {
            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;
            
            if (longer.length === 0) return 1.0;
            
            const editDistance = levenshteinDistance(longer, shorter);
            return (longer.length - editDistance) / longer.length;
        }
        
        function levenshteinDistance(str1, str2) {
            const matrix = [];
            
            for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
            }
            
            for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
            }
            
            for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                    if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            
            return matrix[str2.length][str1.length];
        }

        function handleDrawingStroke(payload) {
            const stroke = payload.new;
            // Only draw strokes from other players
            if (stroke.user_id !== gameState.myId) {
                drawStrokeFromData(stroke.stroke_data);
            }
        }

        function handleRoomUpdate(payload) {
            const room = payload.new;
            if (room.status === 'playing' && !gameState.gameStarted) {
                startGame();
            }
            
            if (room.current_drawer_id) {
                gameState.currentDrawer = room.current_drawer_id;
                updateDrawingPermissions();
            }
            
            if (room.current_word && room.current_drawer_id === gameState.myId) {
                gameState.currentWord = room.current_word;
                document.getElementById('currentWord').textContent = room.current_word;
            }
        }

        function updateDrawingPermissions() {
            const canDraw = gameState.currentDrawer === gameState.myId;
            gameState.isDrawing = canDraw;
            
            // Update UI to show drawing status
            const drawingTools = document.querySelector('.drawing-tools');
            if (drawingTools) {
                drawingTools.style.opacity = canDraw ? '1' : '0.5';
                drawingTools.style.pointerEvents = canDraw ? 'auto' : 'none';
            }
            
            // Show word to drawer
            if (canDraw && gameState.currentWord) {
                document.getElementById('currentWord').textContent = gameState.currentWord;
                document.getElementById('currentWord').style.display = 'block';
            } else {
                document.getElementById('currentWord').style.display = 'none';
            }
        }

        function updatePlayerScore(playerId, newScore) {
            const player = gameState.players.get(playerId);
            if (player) {
                player.score = newScore;
                updatePlayerList();
            }
        }

        function removePlayer(playerId) {
            gameState.players.delete(playerId);
            updatePlayerList();
            
            // Check if room is empty and delete it
            checkAndDeleteEmptyRoom();
        }

        async function checkAndDeleteEmptyRoom() {
            if (!isSupabaseConfigured || !gameState.roomId) return;
            
            try {
                // Check if there are any players left in the room
                const { data: players, error: playersError } = await supabase
                    .from('game_players')
                    .select('id')
                    .eq('room_id', gameState.roomId);

                if (playersError) throw playersError;

                // If no players left, delete the room and related data
                if (players.length === 0) {
                    console.log('Room is empty, cleaning up...');
                    
                    // Delete all messages for this room
                    await supabase
                        .from('game_messages')
                        .delete()
                        .eq('room_id', gameState.roomId);
                    
                    // Delete the room itself
                    await supabase
                        .from('game_rooms')
                        .delete()
                        .eq('id', gameState.roomId);
                    
                    console.log('Empty room deleted successfully');
                }
            } catch (error) {
                console.error('Error checking/deleting empty room:', error);
            }
        }

        // Periodic cleanup of old empty rooms
        async function periodicRoomCleanup() {
            if (!isSupabaseConfigured) return;
            
            try {
                // Find rooms that are older than 1 hour and have no players
                const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000).toISOString();
                
                const { data: emptyRooms, error: roomsError } = await supabase
                    .from('game_rooms')
                    .select(`
                        id,
                        created_at,
                        game_players(id)
                    `)
                    .lt('created_at', oneHourAgo);

                if (roomsError) throw roomsError;

                // Delete rooms that have no players
                for (const room of emptyRooms) {
                    if (room.game_players.length === 0) {
                        // Delete messages first
                        await supabase
                            .from('game_messages')
                            .delete()
                            .eq('room_id', room.id);
                        
                        // Delete the room
                        await supabase
                            .from('game_rooms')
                            .delete()
                            .eq('id', room.id);
                        
                        console.log(`Cleaned up old empty room: ${room.id}`);
                    }
                }
            } catch (error) {
                console.error('Error in periodic room cleanup:', error);
            }
        }

        function updatePlayerList() {
            const playersList = document.getElementById('playersList');
            playersList.innerHTML = '';
            
            // Convert Map to Array and sort by score
            const playersArray = Array.from(gameState.players.values())
                .sort((a, b) => b.score - a.score);
            
            playersArray.forEach(player => {
                const div = document.createElement('div');
                div.className = 'player-item';
                div.innerHTML = `
                    <span class="player-name">${player.name}</span>
                    <span class="player-score">${player.score}</span>
                `;
                
                if (player.id === gameState.currentDrawer) {
                    div.classList.add('current-drawer');
                }
                
                playersList.appendChild(div);
            });
            
            // Update player count display
            const playerCount = gameState.players.size;
            const maxPlayers = 10; // Default max players
            document.getElementById('playerCount').textContent = `${playerCount}/${maxPlayers}`;
        }

        function startGame() {
            gameState.gameStarted = true;
            addSystemMessage('Game started! Get ready to draw and guess!');
            
            // Hide join modal if still open
            document.getElementById('joinModal').style.display = 'none';
            
            // Show start game button for host or in demo mode
            const startBtn = document.getElementById('startGameBtn');
            if (startBtn && (gameState.players.size >= 2 || !isSupabaseConfigured)) {
                startBtn.style.display = 'inline-block';
            }
            
            // Update game phase
            document.getElementById('gamePhase').textContent = 'Ready to start';
        }

        function generateRoomCode() {
            return Math.random().toString(36).substr(2, 6).toUpperCase();
        }

        // Cleanup function for when leaving the game
        async function cleanup() {
            // Remove player from database when leaving
            if (isSupabaseConfigured && gameState.roomId && gameState.myId) {
                try {
                    await supabase
                        .from('game_players')
                        .delete()
                        .eq('room_id', gameState.roomId)
                        .eq('user_id', gameState.myId);
                } catch (error) {
                    console.error('Error removing player on cleanup:', error);
                }
            }
            
            // Unsubscribe from all channels
            gameState.subscriptions.forEach(subscription => {
                supabase.removeChannel(subscription);
            });
            gameState.subscriptions = [];
        }

        // Game state management functions
        async function startNewRound() {
            if (!isSupabaseConfigured) {
                // Demo mode
                const players = Array.from(gameState.players.keys());
                if (players.length === 0) return;
                
                gameState.currentDrawer = players[gameState.currentRound % players.length];
                gameState.currentWord = getRandomWord();
                gameState.timeLeft = 60;
                gameState.roundStarted = true;
                
                updateDrawingPermissions();
                clearCanvas();
                addSystemMessage(`Round ${gameState.currentRound + 1}: ${gameState.players.get(gameState.currentDrawer)?.name} is drawing!`);
                startTimer();
                return;
            }
            
            try {
                // Get random word from database
                const { data: wordData } = await supabase.rpc('get_random_word');
                const word = wordData || 'house';
                
                // Update room with new round info
                const players = Array.from(gameState.players.keys());
                const currentDrawer = players[gameState.currentRound % players.length];
                
                const { error } = await supabase
                    .from('game_rooms')
                    .update({
                        current_drawer: currentDrawer,
                        current_word: word,
                        round_number: gameState.currentRound + 1,
                        time_left: 60,
                        round_started: true
                    })
                    .eq('room_code', gameState.roomId);
                
                if (error) throw error;
                
            } catch (error) {
                console.error('Error starting new round:', error);
                // Fallback to local state
                startNewRound();
            }
        }
        
        async function endRound() {
            gameState.roundStarted = false;
            gameState.timeLeft = 0;
            
            if (isSupabaseConfigured) {
                try {
                    await supabase
                        .from('game_rooms')
                        .update({
                            round_started: false,
                            time_left: 0
                        })
                        .eq('room_code', gameState.roomId);
                } catch (error) {
                    console.error('Error ending round:', error);
                }
            }
            
            addSystemMessage(`Round ended! The word was: ${gameState.currentWord}`);
            
            // Move to next round after delay
            setTimeout(() => {
                gameState.currentRound++;
                if (gameState.currentRound < 3) { // 3 rounds per game
                    startNewRound();
                } else {
                    endGame();
                }
            }, 3000);
        }
        
        function endGame() {
            gameState.gameStarted = false;
            gameState.roundStarted = false;
            
            // Calculate winner
            const players = Array.from(gameState.players.values());
            players.sort((a, b) => b.score - a.score);
            
            if (players.length > 0) {
                addSystemMessage(`ðŸŽ‰ Game Over! Winner: ${players[0].name} with ${players[0].score} points!`);
            }
            
            // Show final scores
            let scoreText = 'Final Scores:\n';
            players.forEach((player, index) => {
                scoreText += `${index + 1}. ${player.name}: ${player.score} points\n`;
            });
            addSystemMessage(scoreText);
        }
        
        function startTimer() {
            if (gameState.timer) {
                clearInterval(gameState.timer);
            }
            
            gameState.timer = setInterval(() => {
                gameState.timeLeft--;
                updateTimerDisplay();
                
                if (gameState.timeLeft <= 0) {
                    clearInterval(gameState.timer);
                    endRound();
                }
            }, 1000);
        }
        
        function updateTimerDisplay() {
            const timerElement = document.getElementById('timer');
            if (timerElement) {
                timerElement.textContent = `${gameState.timeLeft}s`;
            }
        }
        
        function getRandomWord() {
            const words = ['house', 'car', 'tree', 'cat', 'dog', 'sun', 'moon', 'star', 'flower', 'book'];
            return words[Math.floor(Math.random() * words.length)];
        }
        
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Clear strokes from database if configured
            if (isSupabaseConfigured && gameState.roomId) {
                supabase
                    .from('drawing_strokes')
                    .delete()
                    .eq('room_id', gameState.roomId)
                    .then(() => console.log('Canvas cleared'))
                    .catch(error => console.error('Error clearing canvas:', error));
            }
        }
        
        // Handle page unload
        window.addEventListener('beforeunload', cleanup);

        function addPlayer(id, name, score) {
            gameState.players.set(id, { id, name, score });
            updatePlayerList();
        }

        async function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            if (!isSupabaseConfigured) {
                // Demo mode - just add message locally
                const isCorrectGuess = checkGuess(message, gameState.myId);
                addChatMessage(gameState.myName, message, isCorrectGuess ? 'correct-guess' : 'normal');
                
                // Handle correct guess in demo mode
                if (isCorrectGuess) {
                    const points = Math.max(10, Math.floor(gameState.timeLeft / 2));
                    const player = gameState.players.get(gameState.myId);
                    if (player) {
                        player.score += points;
                        updatePlayerList();
                    }
                    
                    addSystemMessage(`ðŸŽ‰ ${gameState.myName} guessed correctly! +${points} points`);
                }
                
                input.value = '';
                return;
            }
            
            if (!gameState.roomId) return;
            
            try {
                // Check if it's a correct guess using enhanced detection
                const isCorrectGuess = checkGuess(message, gameState.myId);
                
                // Add message locally first for immediate feedback
                addChatMessage(gameState.myName, message, isCorrectGuess ? 'correct-guess' : 'normal');
                
                // Save message to database
                const { error } = await supabase
                    .from('game_messages')
                    .insert({
                        room_id: gameState.roomId,
                        user_id: gameState.myId, // Store the full user ID including guest IDs
                        username: gameState.myName,
                        message: message,
                        message_type: isCorrectGuess ? 'guess' : 'chat',
                        is_correct_guess: isCorrectGuess
                    });
                
                if (error) throw error;
                
                // Handle correct guess
                if (isCorrectGuess) {
                    const points = Math.max(10, Math.floor(gameState.timeLeft / 2));
                    await updatePlayerScore(gameState.myId, points);
                    addSystemMessage(`ðŸŽ‰ ${gameState.myName} guessed correctly! +${points} points`);
                }
                
                input.value = '';
                
            } catch (error) {
                console.error('Error sending message:', error);
                // Fallback to local display
                addChatMessage(gameState.myName, message, 'guess');
                input.value = '';
            }
        }

        async function updatePlayerScore(playerId, additionalPoints) {
            try {
                const currentPlayer = gameState.players.get(playerId);
                if (!currentPlayer) return;
                
                const newScore = currentPlayer.score + additionalPoints;
                
                const { error } = await supabase
                    .from('game_players')
                    .update({ score: newScore })
                    .eq('room_id', gameState.roomId)
                    .eq(gameState.myId.startsWith('guest_') ? 'id' : 'user_id', playerId);
                
                if (error) throw error;
                
            } catch (error) {
                console.error('Error updating score:', error);
                // Fallback to local update
                const player = gameState.players.find(p => p.id === playerId);
                if (player) {
                    player.score += additionalPoints;
                    updatePlayerList();
                }
            }
        }

        function addChatMessage(author, text, type = 'guess') {
            const messages = document.getElementById('chatMessages');
            const div = document.createElement('div');
            div.className = `message ${type}`;
            
            div.innerHTML = `
                <span class="message-author">${author}:</span> ${text}
            `;
            
            messages.appendChild(div);
            messages.scrollTop = messages.scrollHeight;
        }

        function addSystemMessage(text) {
            const messages = document.getElementById('chatMessages');
            const div = document.createElement('div');
            div.className = 'message system';
            div.textContent = text;
            
            messages.appendChild(div);
            messages.scrollTop = messages.scrollHeight;
        }

        function calculatePoints() {
            // Points based on time left (more points for faster guesses)
            return Math.max(10, Math.floor(gameState.timeLeft / 2));
        }

        function startNewRound() {
            // Select random word
            gameState.currentWord = words[Math.floor(Math.random() * words.length)];
            
            // Select next player
            const currentIndex = gameState.players.findIndex(p => p.id === gameState.currentPlayer);
            const nextIndex = (currentIndex + 1) % gameState.players.length;
            gameState.currentPlayer = gameState.players[nextIndex].id;
            gameState.isMyTurn = gameState.currentPlayer === gameState.myId;
            
            // Update UI
            if (gameState.isMyTurn) {
                document.getElementById('currentWord').textContent = `Draw: ${gameState.currentWord}`;
                document.getElementById('gamePhase').textContent = 'Your turn to draw!';
            } else {
                document.getElementById('currentWord').textContent = '_ '.repeat(gameState.currentWord.length);
                document.getElementById('gamePhase').textContent = `${gameState.players.find(p => p.id === gameState.currentPlayer).name} is drawing`;
            }
            
            updatePlayerList();
            clearCanvas();
            
            // Start timer
            gameState.timeLeft = 60;
            const timer = setInterval(() => {
                gameState.timeLeft--;
                document.getElementById('gameTimer').textContent = `Time: ${gameState.timeLeft}s`;
                
                if (gameState.timeLeft <= 0) {
                    clearInterval(timer);
                    endRound();
                }
            }, 1000);
        }

        function endRound() {
            addSystemMessage(`Time's up! The word was: ${gameState.currentWord}`);
            setTimeout(startNewRound, 3000);
        }

        // Demo: Start game after a few seconds
        setTimeout(() => {
            if (gameState.players.length >= 2) {
                gameState.currentPlayer = gameState.players[0].id;
                gameState.isMyTurn = gameState.currentPlayer === gameState.myId;
                addSystemMessage('Game starting!');
                setTimeout(startNewRound, 2000);
            }
        }, 5000);

        // Initialize when page loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>