<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DrawGuess - Online Drawing Game | Beniah Games</title>
    
    <!-- Supabase CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        :root {
            --bg: #0d0e10;
            --panel: #171a21;
            --border: #2a2d35;
            --text: #e8eaed;
            --muted: #9aa0a6;
            --accent: #ffcc00;
            --accent-2: #ffe066;
            --success: #34a853;
            --error: #ea4335;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: var(--panel);
            border-bottom: 1px solid var(--border);
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent);
        }

        .room-info {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .room-code {
            background: var(--bg);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .main-container {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 1rem;
            padding: 1rem;
            max-height: calc(100vh - 80px);
        }

        .game-area {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .game-status {
            background: var(--panel);
            padding: 1rem;
            border-radius: 12px;
            border: 1px solid var(--border);
            text-align: center;
        }

        .current-word {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent);
            margin-bottom: 0.5rem;
        }

        .timer {
            font-size: 1.2rem;
            color: var(--muted);
        }

        .canvas-container {
            background: var(--panel);
            border-radius: 12px;
            border: 1px solid var(--border);
            padding: 1rem;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .drawing-tools {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .tool-btn {
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tool-btn:hover {
            background: var(--border);
        }

        .tool-btn.active {
            background: var(--accent);
            color: var(--bg);
        }

        .color-picker {
            display: flex;
            gap: 0.25rem;
        }

        .color-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid var(--border);
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .color-btn:hover {
            transform: scale(1.1);
        }

        .color-btn.active {
            border-color: var(--accent);
            transform: scale(1.2);
        }

        .brush-size {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .size-slider {
            width: 100px;
        }

        #drawingCanvas {
            border: 2px solid var(--border);
            border-radius: 8px;
            background: white;
            cursor: crosshair;
            max-width: 100%;
            max-height: 400px;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .players-panel {
            background: var(--panel);
            border-radius: 12px;
            border: 1px solid var(--border);
            padding: 1rem;
        }

        .panel-title {
            font-weight: bold;
            margin-bottom: 1rem;
            color: var(--accent);
        }

        .player-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .player {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background: var(--bg);
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .player.current-turn {
            border-color: var(--accent);
            background: rgba(255, 204, 0, 0.1);
        }

        .player-name {
            font-weight: 500;
        }

        .player-score {
            color: var(--accent);
            font-weight: bold;
        }

        .chat-panel {
            background: var(--panel);
            border-radius: 12px;
            border: 1px solid var(--border);
            padding: 1rem;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 1rem;
            max-height: 300px;
        }

        .message {
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            border-radius: 8px;
        }

        .message.normal {
            background: var(--bg);
        }

        .message.correct-guess {
            background: rgba(52, 168, 83, 0.2);
            border: 1px solid var(--success);
            font-weight: bold;
        }

        .message.correct {
            background: rgba(52, 168, 83, 0.2);
            border: 1px solid var(--success);
        }

        .message.system {
            background: rgba(255, 204, 0, 0.1);
            border: 1px solid var(--accent);
            font-style: italic;
        }

        .message-author {
            font-weight: bold;
            color: var(--accent);
        }

        .chat-input {
            display: flex;
            gap: 0.5rem;
        }

        .chat-input input {
            flex: 1;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.5rem;
            border-radius: 8px;
        }

        .chat-input button {
            background: var(--accent);
            color: var(--bg);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
        }

        .join-room {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .join-form {
            background: var(--panel);
            padding: 2rem;
            border-radius: 12px;
            border: 1px solid var(--border);
            max-width: 400px;
            width: 90%;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--muted);
        }

        .form-group input {
            width: 100%;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.75rem;
            border-radius: 8px;
        }

        .btn {
            background: var(--accent);
            color: var(--bg);
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            margin-top: 1rem;
        }

        .btn:hover {
            background: var(--accent-2);
        }

        .btn-secondary {
            background: var(--bg);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        @media (max-width: 768px) {
            .main-container {
                display: flex;
                flex-direction: column;
                padding: 0.5rem;
                gap: 0.5rem;
                height: 100vh;
            }
            
            .game-area {
                order: 1;
                flex: 0 0 auto;
                gap: 0.5rem;
            }
            
            .sidebar {
                order: 2;
                display: flex;
                flex-direction: column;
                flex: 1;
                min-height: 0;
            }
            
            .players-panel {
                order: 1;
                flex: 0 0 auto;
                margin: 0;
                padding: 0.75rem;
                max-height: 150px;
                overflow-y: auto;
            }
            
            .chat-panel {
                order: 2;
                flex: 1;
                margin: 0;
                padding: 0.75rem;
                display: flex;
                flex-direction: column;
                min-height: 0;
            }
            
            .chat-messages {
                flex: 1;
                overflow-y: auto;
                min-height: 200px;
            }
            
            .chat-input {
                flex: 0 0 auto;
                margin-top: 0.5rem;
            }
            
            .drawing-tools {
                flex-wrap: wrap;
                gap: 0.5rem;
                justify-content: center;
            }
            
            .drawing-section {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 0.5rem;
            }
            
            #drawingCanvas {
                max-height: 40vh;
                width: 95vw;
                max-width: 95vw;
                height: auto;
                margin: 0 auto;
            }
            
            .game-status {
                padding: 0.75rem;
                margin: 0;
            }
        }
    </style>
</head>
<body>
    <!-- Join Room Modal -->
    <div class="join-room" id="joinModal">
        <div class="join-form">
            <h2 style="margin-bottom: 1rem; color: var(--accent);">Join DrawGuess</h2>
            <div class="form-group">
                <label>Playing as: <span id="currentUserName" style="color: var(--accent); font-weight: bold;">Loading...</span></label>
            </div>
            <div class="form-group">
                <label for="roomCode">Room Code (optional)</label>
                <input type="text" id="roomCode" placeholder="Leave empty to create new room" maxlength="6">
            </div>
            <button class="btn" onclick="joinGame()">Join Game</button>
            <button class="btn btn-secondary" onclick="createRoom()">Create New Room</button>
        </div>
    </div>

    <!-- Main Game Interface -->
    <div class="header">
        <div class="logo">DrawGuess</div>
        <div class="room-info">
            <div class="room-code">Room: <span id="currentRoom">-</span></div>
            <div>Players: <span id="playerCount">0/10</span></div>
        </div>
    </div>

    <div class="main-container">
        <div class="game-area">
            <div class="game-status">
                <div class="current-word" id="currentWord">Waiting for players...</div>
                <div class="timer" id="gameTimer">Time: <span id="timer">0</span>s</div>
                <div id="gamePhase" style="margin-top: 0.5rem; color: var(--muted);">Waiting to start</div>
                <div class="game-controls" style="margin-top: 0.5rem;">
                    <button id="startGameBtn" onclick="startNewRound()" style="display: none; margin-right: 0.5rem;">Start Game</button>
                    <button id="clearCanvasBtn" onclick="clearCanvas()" style="font-size: 0.8rem;">Clear Canvas</button>
                </div>
            </div>

            <div class="canvas-container">
                <div class="drawing-section">
                    <div class="drawing-tools">
                        <button class="tool-btn active" data-tool="pen">Pen</button>
                        <button class="tool-btn" data-tool="eraser">Eraser</button>
                        <button class="tool-btn" onclick="clearCanvas()">Clear</button>
                        
                        <div class="color-picker">
                            <div class="color-btn active" data-color="#000000" style="background: #000000;"></div>
                            <div class="color-btn" data-color="#ff0000" style="background: #ff0000;"></div>
                            <div class="color-btn" data-color="#00ff00" style="background: #00ff00;"></div>
                            <div class="color-btn" data-color="#0000ff" style="background: #0000ff;"></div>
                            <div class="color-btn" data-color="#ffff00" style="background: #ffff00;"></div>
                            <div class="color-btn" data-color="#ff00ff" style="background: #ff00ff;"></div>
                            <div class="color-btn" data-color="#00ffff" style="background: #00ffff;"></div>
                            <div class="color-btn" data-color="#ffffff" style="background: #ffffff; border-color: #666;"></div>
                        </div>
                        
                        <div class="brush-size">
                            <span>Size:</span>
                            <input type="range" class="size-slider" min="1" max="20" value="3" id="brushSize">
                            <span id="sizeDisplay">3px</span>
                        </div>
                    </div>
                    
                    <canvas id="drawingCanvas" width="800" height="400"></canvas>
                </div>
            </div>
        </div>

        <div class="sidebar">
            <div class="players-panel">
                <div class="panel-title">Players</div>
                <div class="player-list" id="playersList">
                    <!-- Players will be populated here -->
                </div>
            </div>

            <div class="chat-panel">
                <div class="panel-title">Chat & Guesses</div>
                <div class="chat-messages" id="chatMessages">
                    <!-- Messages will appear here -->
                </div>
                <form id="chatForm" class="chat-input">
                    <input type="text" id="chatInput" placeholder="Type your guess..." maxlength="100">
                    <button type="submit">Send</button>
                </form>
            </div>
        </div>
    </div>

    <script>
        // Supabase configuration
        // Get these from: https://app.supabase.com → Your Project → Settings → API
        const SUPABASE_URL = 'https://nqhejsnfwfcilktnyqbi.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5xaGVqc25md2ZjaWxrdG55cWJpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgzODQ3NzAsImV4cCI6MjA3Mzk2MDc3MH0.8ngjb28rPVPCj4SnLtLSeUFbeAoFsrcQlZXpq2D19Ag';
        
        // Initialize Supabase client
        let supabase = null;
        let isSupabaseConfigured = false;
        
        try {
            if (SUPABASE_URL !== 'YOUR_SUPABASE_URL' && SUPABASE_ANON_KEY !== 'YOUR_SUPABASE_ANON_KEY') {
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                isSupabaseConfigured = true;
                console.log('Supabase configured - Real-time multiplayer enabled');
            } else {
                console.log('Supabase not configured - Running in demo mode');
                // Show configuration message
                setTimeout(() => {
                    addSystemMessage('⚠️ Demo Mode: To enable real multiplayer, configure Supabase credentials in the code');
                }, 2000);
            }
        } catch (error) {
            console.error('Error initializing Supabase:', error);
            isSupabaseConfigured = false;
        }
        
        // Game state
        let gameState = {
            room: null,
            roomId: null,
            myId: null,
            myName: null,
            players: new Map(),
            currentDrawer: null,
            currentWord: null,
            timeLeft: 60,
            roundEndTime: null,
            timer: null,
            currentRound: 0,
            maxRounds: 3,
            isDrawing: false,
            gameStarted: false,
            roundStarted: false,
            subscriptions: [],
            eventListenersSetup: false,
            canvasSetup: false,
            joiningGame: false,
            currentStrokeBatch: [],
            strokeSaveTimeout: null,
            isGameHost: false,
            gameHostId: null
        };

        // Drawing state
        let canvas, ctx;
        let isDrawingMode = false;
        let currentTool = 'pen';
        let currentColor = '#000000';
        let currentSize = 3;
        let lastX = 0;
        let lastY = 0;

        // Sample words for drawing
        const words = [
            'cat', 'dog', 'house', 'car', 'tree', 'sun', 'moon', 'star', 'fish', 'bird',
            'flower', 'book', 'phone', 'computer', 'chair', 'table', 'door', 'window',
            'apple', 'banana', 'pizza', 'cake', 'ice cream', 'guitar', 'piano', 'ball',
            'bicycle', 'airplane', 'boat', 'train', 'elephant', 'lion', 'butterfly',
            'rainbow', 'cloud', 'mountain', 'ocean', 'beach', 'castle', 'robot'
        ];

        // Initialize game
        async function initGame() {
            canvas = document.getElementById('drawingCanvas');
            ctx = canvas.getContext('2d');
            
            setupCanvas();
            setupEventListeners();
            
            // Get user's name and ID from authentication
            const isAuthenticated = await getUserName();
            if (!isAuthenticated) {
                return; // Stop initialization if not authenticated
            }
            
            // Start periodic room cleanup (every 30 minutes)
            if (isSupabaseConfigured) {
                setInterval(periodicRoomCleanup, 30 * 60 * 1000);
                // Run initial cleanup after 5 seconds
                setTimeout(periodicRoomCleanup, 5000);
            }
        }

        async function getUserName() {
            // Check if user is authenticated
            const user = await getCurrentUser();
            
            if (user && user.username) {
                gameState.myId = user.id;
                gameState.myName = user.username;
                document.getElementById('currentUserName').textContent = user.username;
                return true; // User is authenticated
            } else {
                // User is not authenticated - redirect to main page
                alert('You must be logged in to play. Redirecting to login page...');
                window.location.href = '/';
                return false;
            }
        }

        async function getCurrentUser() {
            if (!isSupabaseConfigured) {
                // Fallback to localStorage for demo mode
                try {
                    const userData = localStorage.getItem('user');
                    if (userData) {
                        return JSON.parse(userData);
                    }
                } catch (e) {
                    console.log('No local user data found');
                }
                return null;
            }
            
            try {
                // Get current Supabase user
                const { data: { user }, error } = await supabase.auth.getUser();
                if (error) throw error;
                
                if (user) {
                    // Get user profile with username
                    const { data: profile, error: profileError } = await supabase
                        .from('profiles')
                        .select('username')
                        .eq('id', user.id)
                        .single();
                    
                    if (profileError) {
                        console.log('No profile found, using email');
                        return { 
                            id: user.id, 
                            username: user.email?.split('@')[0] || 'User' 
                        };
                    }
                    
                    return { 
                        id: user.id, 
                        username: profile.username || user.email?.split('@')[0] || 'User' 
                    };
                }
            } catch (e) {
                console.log('Error getting user:', e);
            }
            
            // Fallback to localStorage for backward compatibility
            try {
                const userData = localStorage.getItem('user');
                if (userData) {
                    return JSON.parse(userData);
                }
            } catch (e) {
                console.log('No local user data found');
            }
            
            return null;
        }

        function setupCanvas() {
            // Prevent duplicate canvas setup
            if (gameState.canvasSetup) return;
            gameState.canvasSetup = true;
            
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = currentSize;
            
            // Mouse events
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            
            // Touch events for mobile with proper options
            canvas.addEventListener('touchstart', handleTouch, { passive: false });
            canvas.addEventListener('touchmove', handleTouch, { passive: false });
            canvas.addEventListener('touchend', handleTouch, { passive: false });
            canvas.addEventListener('touchcancel', stopDrawing, { passive: false });
            
            // Prevent default touch behaviors on canvas
            canvas.style.touchAction = 'none';
        }

        function setupEventListeners() {
            // Prevent duplicate event listeners
            if (gameState.eventListenersSetup) return;
            gameState.eventListenersSetup = true;
            
            // Tool selection
            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelector('.tool-btn.active').classList.remove('active');
                    btn.classList.add('active');
                    currentTool = btn.dataset.tool;
                });
            });

            // Color selection
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelector('.color-btn.active').classList.remove('active');
                    btn.classList.add('active');
                    currentColor = btn.dataset.color;
                    ctx.strokeStyle = currentColor;
                });
            });

            // Brush size
            document.getElementById('brushSize').addEventListener('input', (e) => {
                currentSize = e.target.value;
                ctx.lineWidth = currentSize;
                document.getElementById('sizeDisplay').textContent = currentSize + 'px';
            });

            // Chat form submit
            document.getElementById('chatForm').addEventListener('submit', (e) => {
                e.preventDefault();
                sendMessage();
            });
        }

        async function startDrawing(e) {
            // Allow drawing in demo mode or if user is the current drawer
            if (isSupabaseConfigured && gameState.currentDrawer !== gameState.myId) return;
            
            isDrawingMode = true;
            const rect = canvas.getBoundingClientRect();
            lastX = e.clientX - rect.left;
            lastY = e.clientY - rect.top;
            
            // Clear any existing stroke batch and timeout when starting a new stroke
            if (isSupabaseConfigured) {
                clearTimeout(gameState.strokeSaveTimeout);
                gameState.currentStrokeBatch = [];
                
                // Add start stroke to batch
                gameState.currentStrokeBatch.push({
                    x: lastX,
                    y: lastY,
                    color: currentColor,
                    size: currentSize,
                    tool: currentTool,
                    type: 'start',
                    timestamp: Date.now()
                });
            }
        }

        async function draw(e) {
            if (!isDrawingMode || (isSupabaseConfigured && gameState.currentDrawer !== gameState.myId)) return;
            
            const rect = canvas.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;
            
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(currentX, currentY);
            
            if (currentTool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = currentSize * 2;
            } else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.lineWidth = currentSize;
            }
            
            ctx.stroke();
            
            // Batch stroke data for less frequent database saves
            if (isSupabaseConfigured) {
                // Add to current stroke batch
                if (!gameState.currentStrokeBatch) {
                    gameState.currentStrokeBatch = [];
                }
                
                gameState.currentStrokeBatch.push({
                    fromX: lastX,
                    fromY: lastY,
                    toX: currentX,
                    toY: currentY,
                    color: currentColor,
                    size: currentSize,
                    tool: currentTool,
                    type: 'draw',
                    timestamp: Date.now()
                });
                
                // Save batch every 5 points or after 100ms delay
                if (gameState.currentStrokeBatch.length >= 5) {
                    await saveBatchedStrokes();
                } else {
                    // Debounce individual saves
                    clearTimeout(gameState.strokeSaveTimeout);
                    gameState.strokeSaveTimeout = setTimeout(saveBatchedStrokes, 100);
                }
            }
            
            lastX = currentX;
            lastY = currentY;
        }

        async function saveStroke(strokeData) {
            if (!isSupabaseConfigured) {
                // Demo mode - no need to save strokes
                return;
            }
            
            // Validate required data before database operation
            if (!gameState.roomId || !gameState.myId) {
                console.error('Missing required game state data for stroke:', {
                    roomId: gameState.roomId,
                    myId: gameState.myId
                });
                return;
            }
            
            try {
                console.log('Saving stroke to database:', {
                    roomId: gameState.roomId,
                    userId: gameState.myId,
                    round: gameState.currentRound + 1
                });
                
                const { error } = await supabase
                    .from('drawing_strokes')
                    .insert({
                        room_id: gameState.roomId,
                        user_id: gameState.myId,
                        round_number: gameState.currentRound + 1,
                        stroke_data: strokeData,
                        stroke_order: Date.now() // Timestamp in milliseconds for precise ordering
                    });
                
                if (error) throw error;
                console.log('Stroke saved successfully');
                
            } catch (error) {
                console.error('Error saving stroke:', error);
            }
        }

        async function saveBatchedStrokes() {
            if (!isSupabaseConfigured || !gameState.currentStrokeBatch || gameState.currentStrokeBatch.length === 0) {
                return;
            }
            
            // Clear the timeout if it exists
            clearTimeout(gameState.strokeSaveTimeout);
            
            // Get the batch and clear it immediately to prevent duplicate saves
            const batch = [...gameState.currentStrokeBatch];
            gameState.currentStrokeBatch = [];
            
            // Validate required data before database operation
            if (!gameState.roomId || !gameState.myId) {
                console.error('Missing required game state data for stroke batch');
                return;
            }
            
            try {
                console.log('Saving stroke batch to database:', batch.length, 'strokes');
                
                // Create a single stroke entry with all the batch data
                const { error } = await supabase
                    .from('drawing_strokes')
                    .insert({
                        room_id: gameState.roomId,
                        user_id: gameState.myId,
                        round_number: gameState.currentRound + 1,
                        stroke_data: {
                            type: 'batch',
                            strokes: batch
                        },
                        stroke_order: Date.now()
                    });
                
                if (error) throw error;
                console.log('Stroke batch saved successfully');
                
            } catch (error) {
                console.error('Error saving stroke batch:', error);
            }
        }

        function drawStrokeFromData(strokeData) {
            // Handle batched strokes
            if (strokeData.type === 'batch' && strokeData.strokes) {
                strokeData.strokes.forEach(stroke => {
                    drawSingleStroke(stroke);
                });
                return;
            }
            
            // Handle single stroke
            drawSingleStroke(strokeData);
        }
        
        function drawSingleStroke(strokeData) {
            const { fromX, fromY, toX, toY, color, size, tool, type } = strokeData;
            
            ctx.strokeStyle = color;
            ctx.lineWidth = size;
            
            if (tool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = size * 2;
            } else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.lineWidth = size;
            }
            
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
        }

        async function stopDrawing() {
            isDrawingMode = false;
            
            // Save any remaining batched strokes when drawing stops
            if (isSupabaseConfigured && gameState.currentStrokeBatch && gameState.currentStrokeBatch.length > 0) {
                await saveBatchedStrokes();
            }
        }

        function handleTouch(e) {
            e.preventDefault();
            const touch = e.touches[0];
            
            // Get canvas bounding rect and calculate proper coordinates
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            // Calculate touch coordinates relative to canvas
            const x = (touch.clientX - rect.left) * scaleX;
            const y = (touch.clientY - rect.top) * scaleY;
            
            // Create a synthetic event with proper coordinates
            const syntheticEvent = {
                clientX: rect.left + x / scaleX,
                clientY: rect.top + y / scaleY,
                preventDefault: () => {}
            };
            
            // Handle touch events directly
            if (e.type === 'touchstart') {
                startDrawing(syntheticEvent);
            } else if (e.type === 'touchmove') {
                draw(syntheticEvent);
            } else if (e.type === 'touchend') {
                stopDrawing();
            }
        }

        function clearCanvas() {
            if (!gameState.isMyTurn) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        async function joinGame() {
            // Prevent duplicate calls
            if (gameState.joiningGame) return;
            gameState.joiningGame = true;
            
            const roomCode = document.getElementById('roomCode').value.trim();
            
            // Name is already set by getUserName()
            if (!gameState.myName) {
                alert('Unable to get player name. Please refresh and try again.');
                gameState.joiningGame = false;
                return;
            }
            
            if (!isSupabaseConfigured) {
                // Demo mode - simulate joining
                gameState.room = roomCode.toUpperCase() || generateRoomCode();
                gameState.roomId = gameState.room;
                gameState.players.set(gameState.myId, {
                    id: gameState.myId,
                    name: gameState.myName,
                    score: 0
                });
                
                // Add some demo players
                if (!roomCode) {
                    addPlayer('demo1', 'Demo Player 1', 0);
                    addPlayer('demo2', 'Demo Player 2', 0);
                }
                
                document.getElementById('joinModal').style.display = 'none';
                document.getElementById('currentRoom').textContent = gameState.room;
                addSystemMessage(`${roomCode ? 'Joined' : 'Created'} room: ${gameState.room} (Demo Mode)`);
                startGame();
                return;
            }
            
            try {
                if (roomCode) {
                    // Join existing room
                    await joinExistingRoom(roomCode);
                } else {
                    // Create new room
                    await createNewRoom();
                }
                
                document.getElementById('joinModal').style.display = 'none';
                setupRealtimeSubscriptions();
                gameState.joiningGame = false;
                
            } catch (error) {
                console.error('Error joining game:', error);
                let errorMessage = 'Failed to join game. Please try again.';
                
                // Handle specific database errors
                if (error.code === '42P17') {
                    errorMessage = 'Database configuration error (infinite recursion in security policy). Please contact support.';
                } else if (error.message) {
                    errorMessage = error.message;
                }
                
                alert(errorMessage);
                gameState.joiningGame = false;
            }
        }

        async function createNewRoom() {
            // Generate room code
            const { data: roomCode, error: codeError } = await supabase
                .rpc('generate_room_code');
            
            if (codeError) throw codeError;
            
            // Create room in database
            const { data: room, error: roomError } = await supabase
                .from('game_rooms')
                .insert({
                    room_code: roomCode,
                    host_id: gameState.myId.startsWith('guest_') ? null : gameState.myId,
                    status: 'waiting',
                    max_players: 10
                })
                .select()
                .single();
            
            if (roomError) throw roomError;
            
            gameState.room = roomCode;
            gameState.roomId = room.id;
            document.getElementById('currentRoom').textContent = roomCode;
            
            // Add player to room
            await addPlayerToRoom(room.id);
            
            // Load initial game data (including players)
            await loadInitialGameData();
            
            addSystemMessage(`Room ${roomCode} created! Share this code with friends.`);
        }

        async function joinExistingRoom(roomCode) {
            console.log('Attempting to join room:', roomCode.toUpperCase());
            
            // Find room by code (allow both waiting and playing rooms)
            const { data: room, error: roomError } = await supabase
                .from('game_rooms')
                .select('*')
                .eq('room_code', roomCode.toUpperCase())
                .single();
            
            console.log('Room query result:', { room, roomError });
            
            if (roomError || !room) {
                throw new Error('Room not found');
            }
            
            // If room is playing, check if this player was already in the room
            if (room.status === 'playing') {
                const { data: existingPlayer, error: playerError } = await supabase
                    .from('game_players')
                    .select('*')
                    .eq('room_id', room.id)
                    .eq('user_id', gameState.myId)
                    .single();
                
                if (playerError || !existingPlayer) {
                    throw new Error('Room already started and you are not a participant');
                }
                
                // Player was in the room, allow rejoin
                console.log('Rejoining existing game room');
            }
            
            // Check if room is full
            const { count, error: countError } = await supabase
                .from('game_players')
                .select('*', { count: 'exact', head: true })
                .eq('room_id', room.id);
            
            console.log('Player count check:', { count, countError, roomId: room.id });
            
            if (countError) throw countError;
            
            const maxPlayers = room.max_players || 10; // Default to 10 if not set
            console.log('Room capacity:', { count, maxPlayers });
            
            if (count >= maxPlayers) {
                throw new Error('Room is full');
            }
            
            gameState.room = roomCode.toUpperCase();
            gameState.roomId = room.id;
            document.getElementById('currentRoom').textContent = roomCode.toUpperCase();
            
            // Add player to room
            await addPlayerToRoom(room.id);
            
            // Load initial game data (including players)
            await loadInitialGameData();
            
            addSystemMessage(`Joined room ${roomCode.toUpperCase()}`);
        }

        async function addPlayerToRoom(roomId) {
            // Validate required data before database operation
            if (!roomId || !gameState.myId || !gameState.myName) {
                throw new Error('Missing required data for adding player to room');
            }
            
            const { error } = await supabase
                .from('game_players')
                .upsert({
                    room_id: roomId,
                    user_id: gameState.myId, // Store the full user ID including guest IDs
                    username: gameState.myName,
                    score: 0
                }, {
                    onConflict: 'room_id,user_id'
                });
            
            if (error) {
                throw error;
            }
            
            // Add current player locally immediately to ensure they show up in the count
            // The realtime subscription will handle updates from other players
            addPlayer(gameState.myId, gameState.myName, 0);
            
            // Check if this player should be the game host (first player in the room)
            checkGameHostStatus();
        }

        async function checkGameHostStatus() {
            if (!isSupabaseConfigured || !gameState.roomId) return;
            
            try {
                // Get all players in the room
                const { data: players, error } = await supabase
                    .from('game_players')
                    .select('user_id')
                    .eq('room_id', gameState.roomId);
                
                if (error) throw error;
                
                if (players && players.length > 0) {
                    // Sort players by user_id to get consistent host selection
                    players.sort((a, b) => a.user_id.localeCompare(b.user_id));
                    // First player (lexicographically) is the host
                    gameState.gameHostId = players[0].user_id;
                    gameState.isGameHost = (gameState.gameHostId === gameState.myId);
                    
                    console.log('Game host status:', {
                        hostId: gameState.gameHostId,
                        isHost: gameState.isGameHost,
                        myId: gameState.myId
                    });
                    
                    // Update UI based on host status
                    updateHostUI();
                }
            } catch (error) {
                console.error('Error checking game host status:', error);
            }
        }

        function updateHostUI() {
            const startBtn = document.getElementById('startGameBtn');
            const gamePhase = document.getElementById('gamePhase');
            
            if (gameState.isGameHost) {
                // Show host indicator
                if (gamePhase) {
                    gamePhase.textContent = '👑 Host - ' + (gameState.gameStarted ? 'Game in progress' : 'Waiting for players');
                }
                
                // Show start button if game hasn't started and we have enough players
                if (startBtn && !gameState.gameStarted && gameState.players.size >= 2) {
                    startBtn.style.display = 'inline-block';
                }
            } else {
                // Hide host indicator
                if (gamePhase) {
                    gamePhase.textContent = gameState.gameStarted ? 'Game in progress' : 'Waiting for host to start';
                }
                
                // Hide start button for non-hosts
                if (startBtn) {
                    startBtn.style.display = 'none';
                }
            }
        }

        function createRoom() {
            // Name is already set by getUserName()
            if (!gameState.myName) {
                alert('Unable to get player name. Please refresh and try again.');
                return;
            }
            
            document.getElementById('roomCode').value = '';
            joinGame();
        }

        function setupRealtimeSubscriptions() {
            if (!isSupabaseConfigured || !gameState.roomId) {
                console.log('Skipping subscriptions - Supabase not configured or no room ID');
                return;
            }
            
            // Prevent duplicate subscriptions
            if (gameState.subscriptions.length) {
                console.log('Cleaning up existing subscriptions');
                gameState.subscriptions.forEach(ch => supabase.removeChannel(ch));
                gameState.subscriptions = [];
            }
            
            try {
                console.log('Setting up real-time subscriptions for room:', gameState.roomId);
                
                // Subscribe to players in the room
                const playersSubscription = supabase
                    .channel(`room-${gameState.roomId}-players`)
                    .on('postgres_changes', {
                        event: '*',
                        schema: 'public',
                        table: 'game_players',
                        filter: `room_id=eq.${gameState.roomId}`
                    }, (payload) => {
                        console.log('Player update received:', payload);
                        handlePlayerUpdate(payload);
                    })
                    .subscribe((status) => {
                        console.log('Players subscription status:', status);
                    });

                // Subscribe to messages in the room
                const messagesSubscription = supabase
                    .channel(`room-${gameState.roomId}-messages`)
                    .on('postgres_changes', {
                        event: 'INSERT',
                        schema: 'public',
                        table: 'game_messages',
                        filter: `room_id=eq.${gameState.roomId}`
                    }, (payload) => {
                        console.log('New message received:', payload);
                        handleNewMessage(payload);
                    })
                    .subscribe((status) => {
                        console.log('Messages subscription status:', status);
                    });

                // Subscribe to drawing strokes
                const drawingSubscription = supabase
                    .channel(`room-${gameState.roomId}-drawing`)
                    .on('postgres_changes', {
                        event: 'INSERT',
                        schema: 'public',
                        table: 'drawing_strokes',
                        filter: `room_id=eq.${gameState.roomId}`
                    }, (payload) => {
                        console.log('Drawing stroke received:', payload);
                        handleDrawingStroke(payload);
                    })
                    .subscribe((status) => {
                        console.log('Drawing subscription status:', status);
                    });

                // Subscribe to room updates
                const roomSubscription = supabase
                    .channel(`room-${gameState.roomId}-updates`)
                    .on('postgres_changes', {
                        event: 'UPDATE',
                        schema: 'public',
                        table: 'game_rooms',
                        filter: `id=eq.${gameState.roomId}`
                    }, (payload) => {
                        console.log('Room update received:', payload);
                        handleRoomUpdate(payload);
                    })
                    .subscribe((status) => {
                        console.log('Room subscription status:', status);
                    });

                // Create game state broadcast channel
                const gameStateChannel = supabase
                    .channel(`room-${gameState.roomId}-gamestate`)
                    .on('broadcast', { event: 'game_state_update' }, (payload) => {
                        console.log('Game state broadcast received:', payload);
                        handleGameStateBroadcast(payload);
                    })
                    .subscribe((status) => {
                        console.log('Game state channel status:', status);
                    });

                gameState.gameStateChannel = gameStateChannel;
                gameState.subscriptions = [
                    playersSubscription,
                    messagesSubscription,
                    drawingSubscription,
                    roomSubscription,
                    gameStateChannel
                ];

                console.log('Real-time subscriptions established for room:', gameState.roomId);
                
                // Load initial data
                loadInitialGameData();
            } catch (error) {
                console.error('Error setting up subscriptions:', error);
            }
        }

        function handleGameStateBroadcast(payload) {
            try {
                const { senderId, ...gameStateData } = payload.payload;
                
                // Don't process our own broadcasts
                if (senderId === gameState.myId) {
                    return;
                }
                
                console.log('Processing game state broadcast:', gameStateData);
                
                // Handle different types of game state updates
                if (gameStateData.type === 'game_start') {
                    // Synchronize game start across all players
                    if (!gameState.gameStarted) {
                        gameState.gameStarted = true;
                        gameState.currentRound = gameStateData.currentRound || 0;
                        gameState.currentDrawer = gameStateData.currentDrawer;
                        gameState.currentWord = gameStateData.currentWord;
                        
                        updateDrawingPermissions();
                        clearCanvas();
                        
                        const gamePhaseElement = document.getElementById('gamePhase');
                        if (gamePhaseElement) {
                            if (gameState.currentDrawer === gameState.myId) {
                                gamePhaseElement.textContent = 'Your turn to draw!';
                            } else {
                                const drawerName = gameState.players.get(gameState.currentDrawer)?.name || 'Someone';
                                gamePhaseElement.textContent = `${drawerName} is drawing`;
                            }
                        }
                        
                        addSystemMessage(`Round ${gameState.currentRound + 1}: ${gameState.players.get(gameState.currentDrawer)?.name} is drawing!`);
                    }
                } else if (gameStateData.type === 'round_start') {
                    // Synchronize round start
                    gameState.currentRound = gameStateData.currentRound;
                    gameState.currentDrawer = gameStateData.currentDrawer;
                    gameState.currentWord = gameStateData.currentWord;
                    gameState.roundStarted = gameStateData.roundStarted !== undefined ? gameStateData.roundStarted : true;
                    gameState.gameStarted = gameStateData.gameStarted !== undefined ? gameStateData.gameStarted : true;
                    
                    // Update timer if provided
                    if (gameStateData.timeLeft !== undefined) {
                        gameState.timeLeft = gameStateData.timeLeft;
                        updateTimerDisplay();
                    }
                    
                    updateDrawingPermissions();
                    
                    // Hide join modal if still visible
                    const joinModal = document.getElementById('joinModal');
                    if (joinModal) {
                        joinModal.style.display = 'none';
                    }
                    
                    const gamePhaseElement = document.getElementById('gamePhase');
                    if (gamePhaseElement) {
                        if (gameState.currentDrawer === gameState.myId) {
                            gamePhaseElement.textContent = 'Your turn to draw!';
                        } else {
                            const drawerName = gameState.players.get(gameState.currentDrawer)?.name || 'Someone';
                            gamePhaseElement.textContent = `${drawerName} is drawing`;
                        }
                    }
                    
                    // Only show message if this is a new round start, not a sync
                    if (!gameStateData.gameStarted || gameStateData.roundStarted) {
                        addSystemMessage(`Round ${gameState.currentRound + 1}: ${gameState.players.get(gameState.currentDrawer)?.name} is drawing!`);
                    }
                } else if (gameStateData.type === 'timer_start') {
                    // Synchronize timer across all players
                    console.log('Syncing timer from host:', {
                        timeLeft: gameStateData.timeLeft,
                        roundEndTime: gameStateData.roundEndTime,
                        currentTime: Date.now()
                    });
                    gameState.timeLeft = gameStateData.timeLeft;
                    startTimer(gameStateData.roundEndTime);
                } else if (gameStateData.type === 'round_end') {
                    // Synchronize round end across all players
                    gameState.roundStarted = false;
                    gameState.timeLeft = 0;
                    if (gameState.timer) {
                        clearInterval(gameState.timer);
                    }
                    addSystemMessage(`Round ended! The word was: ${gameStateData.word}`);
                } else if (gameStateData.type === 'game_end') {
                    // Synchronize game end across all players
                    gameState.gameStarted = false;
                    gameState.roundStarted = false;
                    if (gameState.timer) {
                        clearInterval(gameState.timer);
                    }
                    
                    if (gameStateData.winner) {
                        addSystemMessage(`🎉 Game Over! Winner: ${gameStateData.winner.name} with ${gameStateData.winner.score} points!`);
                    }
                    
                    if (gameStateData.finalScores) {
                        let scoreText = 'Final Scores:\n';
                        gameStateData.finalScores.forEach((player, index) => {
                            scoreText += `${index + 1}. ${player.name}: ${player.score} points\n`;
                        });
                        addSystemMessage(scoreText);
                    }
                    
                    // Reset UI for new game
                    resetGameUI();
                }
            } catch (error) {
                console.error('Error handling game state broadcast:', error);
            }
        }

        async function loadInitialGameData() {
            if (!isSupabaseConfigured) {
                // Demo mode - no initial data to load
                return;
            }
            
            try {
                // Load existing players
                const { data: players, error: playersError } = await supabase
                    .from('game_players')
                    .select('*')
                    .eq('room_id', gameState.roomId);

                if (playersError) throw playersError;

                // Add players that aren't already in the local state
                // Don't clear existing players to avoid removing the current player we just added
                players.forEach(player => {
                    if (!gameState.players.has(player.user_id)) {
                        addPlayer(player.user_id, player.username, player.score);
                    }
                });

                // Load recent messages
                const { data: messages, error: messagesError } = await supabase
                    .from('game_messages')
                    .select('*')
                    .eq('room_id', gameState.roomId)
                    .order('created_at', { ascending: true })
                    .limit(50);

                if (messagesError) throw messagesError;

                messages.forEach(msg => {
                    if (msg.message_type === 'system') {
                        addSystemMessage(msg.message);
                    } else if (msg.message_type === 'game_state') {
                        // Check for the most recent game state message
                        try {
                            const gameStateData = JSON.parse(msg.message);
                            if (gameStateData.type === 'game_start') {
                                gameState.gameStarted = true;
                                document.getElementById('gamePhase').textContent = 'Game in progress';
                            } else if (gameStateData.type === 'round_start') {
                                gameState.gameStarted = true;
                                gameState.currentDrawer = gameStateData.drawer;
                                gameState.currentRound = gameStateData.round - 1;
                                gameState.timeLeft = gameStateData.timeLeft;
                                gameState.roundStarted = true;
                                
                                // Update UI
                                updateDrawingPermissions();
                                const gamePhaseElement = document.getElementById('gamePhase');
                                if (gamePhaseElement) {
                                    if (gameState.currentDrawer === gameState.myId) {
                                        gamePhaseElement.textContent = 'Your turn to draw!';
                                    } else {
                                        const drawerName = gameState.players.get(gameState.currentDrawer)?.name || 'Someone';
                                        gamePhaseElement.textContent = `${drawerName} is drawing`;
                                    }
                                }
                            }
                        } catch (error) {
                            console.error('Error parsing game state message:', error);
                        }
                    } else {
                        addChatMessage(msg.username, msg.message);
                    }
                });

            } catch (error) {
                console.error('Error loading initial data:', error);
            }
        }

        async function handlePlayerUpdate(payload) {
            const player = payload.new;
            if (payload.eventType === 'INSERT') {
                addPlayer(player.user_id, player.username, player.score);
                if (player.username !== gameState.myName) {
                    addSystemMessage(`${player.username} joined the room`);
                    
                    // If game is in progress, broadcast current state to sync new player
                    if (gameState.gameStarted) {
                        // Broadcast current game state to sync the new player
                        broadcastGameState({
                            type: gameState.roundStarted ? 'round_start' : 'game_start',
                            currentDrawer: gameState.currentDrawer,
                            currentWord: gameState.currentWord,
                            currentRound: gameState.currentRound,
                            timeLeft: gameState.timeLeft,
                            roundStarted: gameState.roundStarted,
                            gameStarted: gameState.gameStarted
                        });
                    }
                }
            } else if (payload.eventType === 'UPDATE') {
                updatePlayerScore(player.user_id, player.score);
            } else if (payload.eventType === 'DELETE') {
                removePlayer(player.user_id);
                addSystemMessage(`${player.username} left the room`);
            }
        }

        function handleNewMessage(payload) {
            const message = payload.new;
            
            // Skip messages from the current user to avoid duplicates
            if (message.user_id === gameState.myId) {
                return;
            }
            
            if (message.message_type === 'system') {
                addSystemMessage(message.message);
            } else if (message.message_type === 'game_state') {
                // Handle game state synchronization
                try {
                    const gameStateData = JSON.parse(message.message);
                    const senderId = message.user_id;
                    
                    if (gameStateData.type === 'game_start' && senderId !== gameState.myId) {
                        // Synchronize game start for other players
                        gameState.gameStarted = true;
                        document.getElementById('joinModal').style.display = 'none';
                        document.getElementById('gamePhase').textContent = 'Game in progress';
                        document.getElementById('currentWord').textContent = 'Game starting...';
                        addSystemMessage('Game started! Get ready to draw and guess!');
                    } else if (gameStateData.type === 'round_start') {
                        // Only update if this message is not from the current player
                        if (senderId !== gameState.myId) {
                            gameState.currentDrawer = gameStateData.drawer;
                            gameState.currentRound = gameStateData.round - 1; // Adjust for 0-based indexing
                            gameState.timeLeft = gameStateData.timeLeft;
                            gameState.roundStarted = true;
                            
                            // Update UI and permissions
                            updateDrawingPermissions();
                            clearCanvas();
                            
                            // Update game phase
                            const gamePhaseElement = document.getElementById('gamePhase');
                            if (gamePhaseElement) {
                                if (gameState.currentDrawer === gameState.myId) {
                                    gamePhaseElement.textContent = 'Your turn to draw!';
                                } else {
                                    const drawerName = gameState.players.get(gameState.currentDrawer)?.name || 'Someone';
                                    gamePhaseElement.textContent = `${drawerName} is drawing`;
                                }
                            }
                            
                            addSystemMessage(`Round ${gameStateData.round}: ${gameState.players.get(gameStateData.drawer)?.name} is drawing!`);
                            startTimer();
                        }
                    } else if (gameStateData.type === 'timer_start') {
                        // Synchronize timer across all players
                        if (senderId !== gameState.myId) {
                            console.log('Syncing timer from host:', {
                                timeLeft: gameStateData.timeLeft,
                                roundEndTime: gameStateData.roundEndTime,
                                currentTime: Date.now()
                            });
                            gameState.timeLeft = gameStateData.timeLeft;
                            startTimer(gameStateData.roundEndTime);
                        }
                    } else if (gameStateData.type === 'round_end') {
                        // Synchronize round end across all players
                        if (senderId !== gameState.myId) {
                            gameState.roundStarted = false;
                            gameState.timeLeft = 0;
                            if (gameState.timer) {
                                clearInterval(gameState.timer);
                            }
                            addSystemMessage(`Round ended! The word was: ${gameStateData.word}`);
                        }
                    } else if (gameStateData.type === 'game_end') {
                        // Synchronize game end across all players
                        if (senderId !== gameState.myId) {
                            gameState.gameStarted = false;
                            gameState.roundStarted = false;
                            if (gameState.timer) {
                                clearInterval(gameState.timer);
                            }
                            
                            if (gameStateData.winner) {
                                addSystemMessage(`🎉 Game Over! Winner: ${gameStateData.winner.name} with ${gameStateData.winner.score} points!`);
                            }
                            
                            if (gameStateData.finalScores) {
                                 let scoreText = 'Final Scores:\n';
                                 gameStateData.finalScores.forEach((player, index) => {
                                     scoreText += `${index + 1}. ${player.name}: ${player.score} points\n`;
                                 });
                                 addSystemMessage(scoreText);
                             }
                             
                             // Reset UI for new game
                             resetGameUI();
                         }
                    }
                } catch (error) {
                    console.error('Error parsing game state message:', error);
                }
            } else if (message.message_type === 'chat' || message.message_type === 'guess') {
                // Display regular chat messages and guesses from other players
                addChatMessage(message.username, message.message, message.is_correct_guess ? 'correct-guess' : 'normal');
                
                // Check if it's a correct guess
                if (message.is_correct_guess) {
                    addSystemMessage(`🎉 ${message.username} guessed correctly!`);
                }
            }
        }
        
        function checkGuess(message, playerId) {
            if (!gameState.currentWord || !gameState.roundStarted) return false;
            if (playerId === gameState.currentDrawer) return false; // Drawer can't guess
            
            const guess = message.toLowerCase().trim();
            const word = gameState.currentWord.toLowerCase().trim();
            
            // Exact match
            if (guess === word) return true;
            
            // Close match (for typos) - only for longer words
            if (guess.length > 3 && word.length > 3) {
                const similarity = calculateSimilarity(guess, word);
                return similarity > 0.85; // 85% similarity threshold
            }
            
            return false;
        }
        
        function calculateSimilarity(str1, str2) {
            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;
            
            if (longer.length === 0) return 1.0;
            
            const editDistance = levenshteinDistance(longer, shorter);
            return (longer.length - editDistance) / longer.length;
        }
        
        function levenshteinDistance(str1, str2) {
            const matrix = [];
            
            for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
            }
            
            for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
            }
            
            for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                    if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            
            return matrix[str2.length][str1.length];
        }

        function handleDrawingStroke(payload) {
            const stroke = payload.new;
            console.log('Received drawing stroke:', {
                from: stroke.user_id,
                myId: gameState.myId,
                willDraw: stroke.user_id !== gameState.myId
            });
            
            // Only draw strokes from other players
            if (stroke.user_id !== gameState.myId) {
                drawStrokeFromData(stroke.stroke_data);
            }
        }

        function handleRoomUpdate(payload) {
            const room = payload.new;
            if (room.status === 'playing' && !gameState.gameStarted) {
                startGame();
            }
            
            if (room.current_drawer_id) {
                gameState.currentDrawer = room.current_drawer_id;
                updateDrawingPermissions();
            }
            
            if (room.current_word && room.current_drawer_id === gameState.myId) {
                gameState.currentWord = room.current_word;
                document.getElementById('currentWord').textContent = room.current_word;
            }
        }

        function updateDrawingPermissions() {
            const canDraw = gameState.currentDrawer === gameState.myId;
            gameState.isDrawing = canDraw;
            
            // Update UI to show drawing status
            const drawingTools = document.querySelector('.drawing-tools');
            if (drawingTools) {
                drawingTools.style.opacity = canDraw ? '1' : '0.5';
                drawingTools.style.pointerEvents = canDraw ? 'auto' : 'none';
            }
            
            // Update canvas interaction
            const canvas = document.getElementById('drawingCanvas');
            if (canvas) {
                canvas.style.pointerEvents = canDraw ? 'auto' : 'none';
                canvas.style.cursor = canDraw ? 'crosshair' : 'default';
            }
            
            // Show appropriate text to drawer vs guessers
            const currentWordElement = document.getElementById('currentWord');
            if (currentWordElement) {
                if (canDraw && gameState.currentWord) {
                    currentWordElement.textContent = `Draw: ${gameState.currentWord}`;
                } else if (gameState.roundStarted) {
                    currentWordElement.textContent = 'Guess the drawing!';
                } else {
                    currentWordElement.textContent = 'Waiting for players...';
                }
            }
        }

        function updatePlayerScore(playerId, newScore) {
            const player = gameState.players.get(playerId);
            if (player) {
                player.score = newScore;
                updatePlayerList();
            }
        }

        function removePlayer(playerId) {
            gameState.players.delete(playerId);
            updatePlayerList();
            
            // Check if room is empty and delete it
            checkAndDeleteEmptyRoom();
        }

        async function checkAndDeleteEmptyRoom() {
            if (!isSupabaseConfigured || !gameState.roomId) return;
            
            try {
                // Check if there are any players left in the room
                const { data: players, error: playersError } = await supabase
                    .from('game_players')
                    .select('id')
                    .eq('room_id', gameState.roomId);

                if (playersError) throw playersError;

                // If no players left, delete the room and related data
                if (players.length === 0) {
                    console.log('Room is empty, cleaning up...');
                    
                    // Delete all messages for this room
                    await supabase
                        .from('game_messages')
                        .delete()
                        .eq('room_id', gameState.roomId);
                    
                    // Delete the room itself
                    await supabase
                        .from('game_rooms')
                        .delete()
                        .eq('id', gameState.roomId);
                    
                    console.log('Empty room deleted successfully');
                }
            } catch (error) {
                console.error('Error checking/deleting empty room:', error);
            }
        }

        // Periodic cleanup of old empty rooms
        async function periodicRoomCleanup() {
            if (!isSupabaseConfigured) return;
            
            try {
                // Find rooms that are older than 1 hour and have no players
                const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000).toISOString();
                
                const { data: emptyRooms, error: roomsError } = await supabase
                    .from('game_rooms')
                    .select(`
                        id,
                        created_at,
                        game_players(id)
                    `)
                    .lt('created_at', oneHourAgo);

                if (roomsError) throw roomsError;

                // Delete rooms that have no players
                for (const room of emptyRooms) {
                    if (room.game_players.length === 0) {
                        // Delete messages first
                        await supabase
                            .from('game_messages')
                            .delete()
                            .eq('room_id', room.id);
                        
                        // Delete the room
                        await supabase
                            .from('game_rooms')
                            .delete()
                            .eq('id', room.id);
                        
                        console.log(`Cleaned up old empty room: ${room.id}`);
                    }
                }
            } catch (error) {
                console.error('Error in periodic room cleanup:', error);
            }
        }

        function updatePlayerList() {
            const playersList = document.getElementById('playersList');
            playersList.innerHTML = '';
            
            // Convert Map to Array and sort by score
            const playersArray = Array.from(gameState.players.values())
                .sort((a, b) => b.score - a.score);
            
            playersArray.forEach(player => {
                const div = document.createElement('div');
                div.className = 'player-item';
                div.innerHTML = `
                    <span class="player-name">${player.name}</span>
                    <span class="player-score">${player.score}</span>
                `;
                
                if (player.id === gameState.currentDrawer) {
                    div.classList.add('current-drawer');
                }
                
                playersList.appendChild(div);
            });
            
            // Update player count display
            const playerCount = gameState.players.size;
            const maxPlayers = 10; // Default max players
            document.getElementById('playerCount').textContent = `${playerCount}/${maxPlayers}`;
            
            // Update host UI when player list changes
            updateHostUI();
        }

        async function startGame() {
            // Only the game host should start games in multiplayer mode
            if (isSupabaseConfigured && !gameState.isGameHost) {
                console.log('Not game host, cannot start game');
                return;
            }
            
            gameState.gameStarted = true;
            addSystemMessage('Game started! Get ready to draw and guess!');
            
            // Hide join modal if still open
            document.getElementById('joinModal').style.display = 'none';
            
            // Hide start button
            const startBtn = document.getElementById('startGameBtn');
            if (startBtn) {
                startBtn.style.display = 'none';
            }
            
            // Update game phase
            document.getElementById('gamePhase').textContent = 'Game in progress';
            document.getElementById('currentWord').textContent = 'Game starting...';
            
            // Update host UI
            updateHostUI();
            
            // Update room status in database and broadcast game start
            if (isSupabaseConfigured && gameState.roomId) {
                try {
                    await supabase
                        .from('game_rooms')
                        .update({ status: 'playing' })
                        .eq('id', gameState.roomId);
                    
                    // Broadcast game start to other players
                    await supabase
                        .from('game_messages')
                        .insert({
                            room_id: gameState.roomId,
                            user_id: gameState.myId,
                            username: 'System',
                            message: JSON.stringify({
                                type: 'game_start'
                            }),
                            message_type: 'game_state'
                        });
                } catch (error) {
                    console.error('Error updating room status:', error);
                }
            }
            
            // Start the first round after a short delay
            setTimeout(() => {
                startNewRound();
            }, 2000);
        }

        function generateRoomCode() {
            return Math.random().toString(36).substr(2, 6).toUpperCase();
        }

        // Cleanup function for when leaving the game
        async function cleanup() {
            // Remove player from database when leaving
            if (isSupabaseConfigured && gameState.roomId && gameState.myId) {
                try {
                    await supabase
                        .from('game_players')
                        .delete()
                        .eq('room_id', gameState.roomId)
                        .eq('user_id', gameState.myId);
                } catch (error) {
                    console.error('Error removing player on cleanup:', error);
                }
            }
            
            // Unsubscribe from all channels
            gameState.subscriptions.forEach(subscription => {
                supabase.removeChannel(subscription);
            });
            gameState.subscriptions = [];
        }

        // Game state management functions
        async function startNewRound() {
            // Only the game host should manage rounds in multiplayer mode
            if (isSupabaseConfigured && !gameState.isGameHost) {
                console.log('Not game host, skipping round management');
                return;
            }
            
            if (!isSupabaseConfigured) {
                // Demo mode
                const players = Array.from(gameState.players.keys());
                if (players.length === 0) return;
                
                gameState.currentDrawer = players[gameState.currentRound % players.length];
                gameState.currentWord = getRandomWord();
                gameState.timeLeft = 60;
                gameState.roundStarted = true;
                
                updateDrawingPermissions();
                clearCanvas();
                
                // Update game phase for demo mode
                const gamePhaseElement = document.getElementById('gamePhase');
                if (gamePhaseElement) {
                    if (gameState.currentDrawer === gameState.myId) {
                        gamePhaseElement.textContent = 'Your turn to draw!';
                    } else {
                        const drawerName = gameState.players.get(gameState.currentDrawer)?.name || 'Someone';
                        gamePhaseElement.textContent = `${drawerName} is drawing`;
                    }
                }
                
                addSystemMessage(`Round ${gameState.currentRound + 1}: ${gameState.players.get(gameState.currentDrawer)?.name} is drawing!`);
                startTimer();
                return;
            }
            
            try {
                // Get random word (fallback to local words array)
                const word = getRandomWord();
                
                // Select next drawer
                const players = Array.from(gameState.players.keys());
                const currentDrawer = players[gameState.currentRound % players.length];
                
                // Update local state
                gameState.currentDrawer = currentDrawer;
                gameState.currentWord = word;
                gameState.timeLeft = 60;
                gameState.roundStarted = true;
                
                // Update UI and permissions
                updateDrawingPermissions();
                clearCanvas();
                
                // Broadcast game state to other players via system message
                if (isSupabaseConfigured && gameState.roomId) {
                    await supabase
                        .from('game_messages')
                        .insert({
                            room_id: gameState.roomId,
                            user_id: gameState.myId,
                            username: 'System',
                            message: JSON.stringify({
                                type: 'round_start',
                                drawer: currentDrawer,
                                round: gameState.currentRound + 1,
                                timeLeft: 60
                            }),
                            message_type: 'game_state'
                        });
                }
                
                // Update game phase
                const gamePhaseElement = document.getElementById('gamePhase');
                if (gamePhaseElement) {
                    if (currentDrawer === gameState.myId) {
                        gamePhaseElement.textContent = 'Your turn to draw!';
                    } else {
                        const drawerName = gameState.players.get(currentDrawer)?.name || 'Someone';
                        gamePhaseElement.textContent = `${drawerName} is drawing`;
                    }
                }
                
                addSystemMessage(`Round ${gameState.currentRound + 1}: ${gameState.players.get(currentDrawer)?.name} is drawing!`);
                startTimer();
                
            } catch (error) {
                console.error('Error starting new round:', error);
                // Fallback to demo mode logic
                const players = Array.from(gameState.players.keys());
                if (players.length === 0) return;
                
                gameState.currentDrawer = players[gameState.currentRound % players.length];
                gameState.currentWord = getRandomWord();
                gameState.timeLeft = 60;
                gameState.roundStarted = true;
                
                updateDrawingPermissions();
                clearCanvas();
                
                // Update game phase for fallback
                const gamePhaseElement = document.getElementById('gamePhase');
                if (gamePhaseElement) {
                    if (gameState.currentDrawer === gameState.myId) {
                        gamePhaseElement.textContent = 'Your turn to draw!';
                    } else {
                        const drawerName = gameState.players.get(gameState.currentDrawer)?.name || 'Someone';
                        gamePhaseElement.textContent = `${drawerName} is drawing`;
                    }
                }
                
                addSystemMessage(`Round ${gameState.currentRound + 1}: ${gameState.players.get(gameState.currentDrawer)?.name} is drawing!`);
                startTimer();
            }
        }
        
        async function endRound() {
            // Only the game host should end rounds in multiplayer mode
            if (isSupabaseConfigured && !gameState.isGameHost) {
                console.log('Not game host, skipping round end');
                return;
            }
            
            gameState.roundStarted = false;
            gameState.timeLeft = 0;
            
            if (isSupabaseConfigured) {
                try {
                    await supabase
                        .from('game_rooms')
                        .update({
                            round_started: false,
                            time_left: 0
                        })
                        .eq('room_code', gameState.roomId);
                } catch (error) {
                    console.error('Error ending round:', error);
                }
            }
            
            addSystemMessage(`Round ended! The word was: ${gameState.currentWord}`);
            
            // Broadcast round end to all players
            if (isSupabaseConfigured) {
                broadcastGameState({
                    type: 'round_end',
                    word: gameState.currentWord,
                    currentRound: gameState.currentRound
                });
            }
            
            // Move to next round after delay
            setTimeout(() => {
                gameState.currentRound++;
                if (gameState.currentRound < 3) { // 3 rounds per game
                    startNewRound();
                } else {
                    endGame();
                }
            }, 3000);
        }
        
        function endGame() {
            // Only the game host should end games in multiplayer mode
            if (isSupabaseConfigured && !gameState.isGameHost) {
                console.log('Not game host, skipping game end');
                return;
            }
            
            gameState.gameStarted = false;
            gameState.roundStarted = false;
            
            // Calculate winner
            const players = Array.from(gameState.players.values());
            players.sort((a, b) => b.score - a.score);
            
            if (players.length > 0) {
                addSystemMessage(`🎉 Game Over! Winner: ${players[0].name} with ${players[0].score} points!`);
            }
            
            // Show final scores
            let scoreText = 'Final Scores:\n';
            players.forEach((player, index) => {
                scoreText += `${index + 1}. ${player.name}: ${player.score} points\n`;
            });
            addSystemMessage(scoreText);
            
            // Broadcast game end to all players
            if (isSupabaseConfigured) {
                broadcastGameState({
                    type: 'game_end',
                    winner: players[0],
                    finalScores: players
                });
            }
            
            // Reset UI for new game
            resetGameUI();
        }
        
        function resetGameUI() {
            // Reset game state
            gameState.currentRound = 0;
            gameState.currentDrawer = null;
            gameState.currentWord = '';
            gameState.timeLeft = 60;
            
            // Clear canvas
            clearCanvas();
            
            // Update UI elements
            const gamePhaseElement = document.getElementById('gamePhase');
            if (gamePhaseElement) {
                gamePhaseElement.textContent = 'Waiting for game to start...';
            }
            
            const timerElement = document.getElementById('timer');
            if (timerElement) {
                timerElement.textContent = '60';
            }
            
            const currentWordElement = document.getElementById('currentWord');
            if (currentWordElement) {
                currentWordElement.textContent = '';
            }
            
            // Show start button for host
            if (gameState.isGameHost) {
                const startGameBtn = document.getElementById('startGameBtn');
                if (startGameBtn) {
                    startGameBtn.style.display = 'block';
                }
            }
            
            updateHostUI();
        }
        
        function startTimer(roundEndTime = null) {
            if (gameState.timer) {
                clearInterval(gameState.timer);
            }
            
            // If no end time provided, calculate it (only for the drawer/host)
            if (!roundEndTime) {
                roundEndTime = Date.now() + (gameState.timeLeft * 1000);
                
                // Only the game host should broadcast the timer start
                if (isSupabaseConfigured && gameState.isGameHost) {
                    console.log('Host broadcasting timer start:', {
                        timeLeft: gameState.timeLeft,
                        roundEndTime: roundEndTime,
                        currentTime: Date.now()
                    });
                    broadcastGameState({
                        type: 'timer_start',
                        roundEndTime: roundEndTime,
                        timeLeft: gameState.timeLeft
                    });
                }
            } else {
                console.log('Starting timer with provided end time:', {
                    roundEndTime: roundEndTime,
                    currentTime: Date.now(),
                    calculatedTimeLeft: Math.ceil((roundEndTime - Date.now()) / 1000)
                });
            }
            
            gameState.roundEndTime = roundEndTime;
            
            gameState.timer = setInterval(() => {
                const now = Date.now();
                gameState.timeLeft = Math.max(0, Math.ceil((gameState.roundEndTime - now) / 1000));
                updateTimerDisplay();
                
                if (gameState.timeLeft <= 0) {
                    clearInterval(gameState.timer);
                    // Only the game host should end the round to prevent duplicates
                    if (gameState.isGameHost) {
                        endRound();
                    }
                }
            }, 100); // Update more frequently for better sync
        }
        
        function updateTimerDisplay() {
            const timerElement = document.getElementById('timer');
            if (timerElement) {
                timerElement.textContent = `${gameState.timeLeft}s`;
            }
        }
        
        async function broadcastGameState(gameStateData) {
            if (!isSupabaseConfigured || !gameState.roomId || !gameState.myId) return;
            
            try {
                // Use real-time channel broadcasting instead of database insert
                if (gameState.gameStateChannel) {
                    console.log('Broadcasting game state via channel:', gameStateData);
                    await gameState.gameStateChannel.send({
                        type: 'broadcast',
                        event: 'game_state_update',
                        payload: {
                            ...gameStateData,
                            senderId: gameState.myId,
                            timestamp: Date.now()
                        }
                    });
                } else {
                    console.log('No game state channel available for broadcast');
                }
            } catch (error) {
                console.error('Error broadcasting game state:', error);
            }
        }
        
        function getRandomWord() {
            const words = ['house', 'car', 'tree', 'cat', 'dog', 'sun', 'moon', 'star', 'flower', 'book'];
            return words[Math.floor(Math.random() * words.length)];
        }
        
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Clear strokes from database if configured
            if (isSupabaseConfigured && gameState.roomId) {
                supabase
                    .from('drawing_strokes')
                    .delete()
                    .eq('room_id', gameState.roomId)
                    .then(() => console.log('Canvas cleared'))
                    .catch(error => console.error('Error clearing canvas:', error));
            }
        }
        
        // Handle page unload
        window.addEventListener('beforeunload', cleanup);

        function addPlayer(id, name, score) {
            gameState.players.set(id, { id, name, score });
            updatePlayerList();
            
            // Auto-start game when we have 2 or more players
            if (gameState.players.size >= 2 && !gameState.gameStarted) {
                setTimeout(() => {
                    if (gameState.players.size >= 2 && !gameState.gameStarted) {
                        startGame();
                    }
                }, 2000); // Wait 2 seconds to allow other players to join
            }
        }

        async function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            if (!isSupabaseConfigured) {
                // Demo mode - just add message locally
                const isCorrectGuess = checkGuess(message, gameState.myId);
                addChatMessage(gameState.myName, message, isCorrectGuess ? 'correct-guess' : 'normal');
                
                // Handle correct guess in demo mode
                if (isCorrectGuess) {
                    const points = Math.max(10, Math.floor(gameState.timeLeft / 2));
                    const player = gameState.players.get(gameState.myId);
                    if (player) {
                        player.score += points;
                        updatePlayerList();
                    }
                    
                    addSystemMessage(`🎉 ${gameState.myName} guessed correctly! +${points} points`);
                }
                
                input.value = '';
                return;
            }
            
            // Validate required data before database operation
            if (!gameState.roomId || !gameState.myId || !gameState.myName) {
                console.error('Missing required game state data:', {
                    roomId: gameState.roomId,
                    myId: gameState.myId,
                    myName: gameState.myName
                });
                addSystemMessage('Error: Unable to send message. Please rejoin the room.');
                input.value = '';
                return;
            }
            
            try {
                // Check if it's a correct guess using enhanced detection
                const isCorrectGuess = checkGuess(message, gameState.myId);
                
                // Display message locally immediately for better UX
                addChatMessage(gameState.myName, message, isCorrectGuess ? 'correct-guess' : 'normal');
                
                // Save message to database (will be received via subscription for other players)
                const { error } = await supabase
                    .from('game_messages')
                    .insert({
                        room_id: gameState.roomId,
                        user_id: gameState.myId, // Store the full user ID including guest IDs
                        username: gameState.myName,
                        message: message,
                        message_type: isCorrectGuess ? 'guess' : 'chat',
                        is_correct_guess: isCorrectGuess
                    });
                
                if (error) throw error;
                
                // Handle correct guess
                if (isCorrectGuess) {
                    const points = Math.max(10, Math.floor(gameState.timeLeft / 2));
                    await updatePlayerScore(gameState.myId, points);
                    addSystemMessage(`🎉 ${gameState.myName} guessed correctly! +${points} points`);
                }
                
                input.value = '';
                
            } catch (error) {
                console.error('Error sending message:', error);
                // Fallback to local display
                addChatMessage(gameState.myName, message, 'guess');
                input.value = '';
            }
        }

        async function updatePlayerScore(playerId, additionalPoints) {
            try {
                const currentPlayer = gameState.players.get(playerId);
                if (!currentPlayer) return;
                
                const newScore = currentPlayer.score + additionalPoints;
                
                const { error } = await supabase
                    .from('game_players')
                    .update({ score: newScore })
                    .eq('room_id', gameState.roomId)
                    .eq('user_id', playerId);
                
                if (error) throw error;
                
            } catch (error) {
                console.error('Error updating score:', error);
                // Fallback to local update
                const player = gameState.players.find(p => p.id === playerId);
                if (player) {
                    player.score += additionalPoints;
                    updatePlayerList();
                }
            }
        }

        function addChatMessage(author, text, type = 'guess') {
            const messages = document.getElementById('chatMessages');
            const div = document.createElement('div');
            div.className = `message ${type}`;
            
            div.innerHTML = `
                <span class="message-author">${author}:</span> ${text}
            `;
            
            messages.appendChild(div);
            messages.scrollTop = messages.scrollHeight;
        }

        function addSystemMessage(text) {
            const messages = document.getElementById('chatMessages');
            const div = document.createElement('div');
            div.className = 'message system';
            div.textContent = text;
            
            messages.appendChild(div);
            messages.scrollTop = messages.scrollHeight;
        }

        function calculatePoints() {
            // Points based on time left (more points for faster guesses)
            return Math.max(10, Math.floor(gameState.timeLeft / 2));
        }

        // Initialize when page loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>